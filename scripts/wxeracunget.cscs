// -----------------------------------------------------------
// WxEracunGet.cscs - UBL XML Invoice Import Program
// -----------------------------------------------------------
// Purpose: Import UBL XML invoices into database tables
// Main Function: importUBLXml(xmlFilePath)
// Created: November 19, 2025
// Compatible with: wxeracun.cscs export format
// -----------------------------------------------------------
// Global variables for database connection
//databaseName = "your_database_name"; // Update with actual database name

Import(strTrim(mpath()) + "CSCS.Math.dll");

CreateWindow(strTrim(tpath()) + "wxeracunget.xaml");

DEFINE Rbr type i;
DEFINE cntr1 type i;

DEFINE arrayRbr type i size 100 array 10000;
DEFINE arrayDobavljac type a size 500 array 10000;
DEFINE arrayOibDobavljaca type a size 11 array 10000;
DEFINE arrayDatumIzdavanja type a size 10 array 10000;
DEFINE arrayDatumPDVa type a size 10 array 10000;
DEFINE arrayBrojRacuna type a size 50 array 10000;

DEFINE arrayBrojRacunaFina type a size 50 array 10000;
DEFINE arrayBrojRacunaMer type a size 50 array 10000;

// savedXmlFilesList = {};

function wxeracunget_onDisplay(){
    cursor("wait");
    SetWidgetOptions("btnPreuzmi", "IsEnabled", "false");
    SetWidgetOptions("StatusLabel", "Content", "Dohvaćanje liste ulaznih e-računa");
    SetWidgetOptions("StatusLabel2", "Content", "Pričekajte...");

    try{
        init();
        SetWindowOptions("wxeracungetWindow", "title", "Preuzimanje ulaznih e-računa(" + PROVIDER + ")");
        getList();
        DisplayArraySetup("datagridListaRacuna", counterFld: cntr1, activeElements: Rbr, maxElements: Rbr);
    }catch(ex){
        MessageBox("Greška pri inicijalizaciji:\n" + ex);
        // ??? LOG? ne?
        exit;
    }
    
    cursor("dflt");
    SetWidgetOptions("btnPreuzmi", "IsEnabled", "true");
    SetWidgetOptions("StatusLabel", "Content", "");
    SetWidgetOptions("StatusLabel2", "Content", "");
}

function init(){
    args = CommandLineArgs(); 
    if(Size(args) > 2){
        companyCode = args[2]; // e.g. Y3
        CoSet(companyCode);

        if(Size(args) > 3){
            userCode = args[3]; // e.g. ANA

        }else{
            MessageBox("Nedostaje user code u argumentima.");
            exit;
        }
    }else{
        companyCode = Substring(CoGet(), 1, 2);
    }


    // NKSYCCYR
    sqlQueryString = "select SY_CC_USER, SY_CC_DBASE from " + strtrim(CommonDBGet()) + ".dbo.NKSYCCYR WHERE SY_CC_CODE = '" + companyCode + "'";
    try
    {
        sqlResult = sqlQuery(sqlQueryString);
    }
    catch(ex)
    {
        MessageBox("Greška čitanja NKSYCCYR:\n" + ex);
        // ??? LOG? ne?
        exit;
    }

    if (size(sqlResult) > 1)
    {
        // imeFirme = sqlResult[1][0].trim(); // KAMEND
        // ovagod_h = sqlResult[1][1].trim(); // 2022
        SY_CC_USER = sqlResult[1][0].trim(); // KAMEND
        databaseName = sqlResult[1][1].trim(); // ime baze
    }    


    // NKSYSYCO Configuration
    sqlQueryString = " SELECT NKSYS_FIELD, NKSYS_VALUE 
        FROM " + databaseName + ".dbo.NKSYSYCO 
        WHERE NKSYS_MODUL = 'WKSY'
        AND NKSYS_GRUP = 'ERACUN'";
    try
    {
        sqlResult = sqlQuery(sqlQueryString);
    }
    catch(ex)
    {
        MessageBox("Greška čitanja NKSYSYCO:\n" + ex);
        // ??? LOG? ne?
        exit;
    }
    if (size(sqlResult) > 1)
    {
        for(i = 1; i < Size(sqlResult); i++){
            if(sqlResult[i][0].trim() == "FILESPATH"){
                FILESPATH = sqlResult[i][1].trim();
            }
            elif(sqlResult[i][0].trim() == "PROVIDER")
            {
                PROVIDER = sqlResult[i][1].trim();
            }
            elif(sqlResult[i][0].trim() == "SCHEMASPATH")
            {
                SCHEMASPATH = sqlResult[i][1].trim();
            }elif(sqlResult[i][0].trim() == "CERTPATH"){
                CERTPATH = sqlResult[i][1].trim();
            }
            
        }
    }


    // KPSYMSTR
    sqlQueryString = " SELECT TOP 1 KPSY_REZERVA, KPSY_COMP_NAME, KPSY_COMP_ADD1, KPSY_GL_RETEARN, KPSY_COMP_CSZ, KPSY_COMP_ZIP,
                    KPSY_COMP_JMBFI, KPSY_COMP_PHONE, KPSY_COMP_EMAIL, KPSY_PO_FREIGHT, KPSY_REZERVAX,KPSY_FISCAL_YR
                        FROM " + databaseName + ".dbo.KPSYMSTR";
    try
    {
        sqlResult = sqlQuery(sqlQueryString);
    }
    catch(ex)
    {
        MessageBox("Greška čitanja KPSYMSTR:\n" + ex);
        // !!! LOG ???
        exit;
    }

    if (size(sqlResult) > 1)
    {
        // proslaGodina = (int(ovagod_h) - 1);
        // nazivFirme = sqlResult[1][0].trim();
        // kpsy_po_freight= sqlResult[1][1].trim();
        // fiscal_yr = sqlResult[1][2];
        // local = sqlResult[1][3];

        KPSY_REZERVA = sqlResult[1][0].trim();
        KPSY_COMP_NAME = sqlResult[1][1].trim();
        KPSY_COMP_ADD1 = sqlResult[1][2].trim();
        KPSY_GL_RETEARN = sqlResult[1][3].trim();
        KPSY_COMP_CSZ = sqlResult[1][4].trim();
        KPSY_COMP_ZIP = sqlResult[1][5];
        KPSY_COMP_JMBFI = sqlResult[1][6].trim();
        KPSY_COMP_PHONE = sqlResult[1][7].trim();
        KPSY_COMP_EMAIL = sqlResult[1][8].trim();
        KPSY_PO_FREIGHT = substring(sqlResult[1][9], 0, 2).trim();
        KPSY_REZERVAX = sqlResult[1][10].trim(); // Supplier GLN
        KPSY_FISCAL_YR = sqlResult[1][11].trim();
    } 
}

function getList(){
    try {
        sql_erac = "SELECT
                ERAC_REZ1, ERAC_SERVER, ERAC_SERVERT, ERAC_USER, ERAC_PASS, ERAC_USERT, ERAC_PASST, ERAC_DESC 
                FROM " + databaseName + ".dbo.NKSYERAC WHERE ERAC_CODE = @p1;";
        sqlParams = {};
        // if(NKSC_POSREDNIK != ""){
        //     sqlParams.Add({"@p1", NKSC_POSREDNIK});
        //     PROVIDER = NKSC_POSREDNIK;
        // }else{
            sqlParams.Add({"@p1", PROVIDER});
        // }
        
        eracRes = sqlQuery(sql_erac, sqlParams);
        if (Size(eracRes) < 2) {
            MessageBox("Nema podataka o posredniku " + PROVIDER + "!");
            // !!! LOG !!!
            exit;
        }

        ERAC_REZ1 = eracRes[1][0].trim();
        ERAC_SERVER = eracRes[1][1].trim();
        ERAC_SERVERT = eracRes[1][2].trim();
        ERAC_USER = eracRes[1][3].trim();
        ERAC_PASS = eracRes[1][4].trim();
        ERAC_USERT = eracRes[1][5].trim(); // cer certificate
        ERAC_PASST = eracRes[1][6].trim(); // p12 certificate
        ERAC_DESC = eracRes[1][7].trim();
        
        companyOIB = substring(KPSY_REZERVA, 0, 11).trim();

        if (PROVIDER == "MER" || PROVIDER == "MERDEMO") {
            GetListMER();
        } elif (PROVIDER == "FINA" || PROVIDER == "FINADEMO") {
            GetListFINA();
        } else {
            MessageBox("Nepoznat provider: " + PROVIDER + ". Podržani su: MER, FINA");
            exit;
        }
    } catch (ex) {
        MessageBox("Greška u preuzimanju sa provider-a " + PROVIDER + ": " + ex);
        // !!! LOG !!!
        exit;
    }
}

function GetListFINA(){
    // GET INCOMING INVOICE LIST
    try{
        //MSG("Dohvaćam listu ULAZNIH računa preko FINA-e putem WSDL-a!");
        ack = FINA_GET_B2B_INCOMING_INVOICE_LIST(
            ERAC_SERVER + "B2BFinaInvoiceWebService/services/B2BFinaInvoiceWebService",
            ERAC_DESC, // "e-invoice" / NE "e-racun-winx" !
            CERTPATH + ERAC_USERT, // servisni certifikat
            CERTPATH + ERAC_PASST, // p12 certifikat (klijentski)
            ERAC_PASS, // password za p12 certifikat

            UUID(), // messageId
            "9934:" + companyOIB // OIB primatelja (VLASTITI) // !!! stavit pravi OIB iz baze
        );

        // MSG("ack = " + ack);
       
        // MSG("ackStatusText = " + ack["ackstatustext"]);

        if(ack["AckStatusCode"] == 10){
            if(!Contains(ack, "ErrorCode")){
                // MSG("U listi je " + Size(ack["InvoiceList"]) + " računa za preuzimanje sa FINA servera.");
                for(i = 0; i < Size(ack["InvoiceList"]); i++){
                    // MSG(ack["InvoiceList"][i]);

                    supplierName = ack["InvoiceList"][i]["SupplierRegistrationName"];
                    supplierId = ack["InvoiceList"][i]["SupplierId"];
                    // !!! datumi (2)
                    supplierInvoiceId = ack["InvoiceList"][i]["SupplierInvoiceID"];
                    invoiceId = ack["InvoiceList"][i]["InvoiceID"];

                    datumIzdavanja = ack["InvoiceList"][i]["InvoiceIssueDate"];
                    datumIzdavanja = Substring(datumIzdavanja, 0, 8);
                    datumPdva = ack["InvoiceList"][i]["InvoiceDate"];
                    datumPdva = Substring(datumPdva, 0, 8);

                    AddRacunToArrays(supplierName, supplierId, datumIzdavanja, datumPdva, supplierInvoiceId, invoiceId);
                }
            }else{
                MessageBox("ack[\"ErrorCode\"]" + ack["ErrorCode"] + "\nack[\"ErrorText\"]" + ack["ErrorText"] + "\nack[\"ErrorMessage\"]" + ack["ErrorMessage"]);
                exit;
            }
        }else{
            MessageBox("AckStatusText = " + ack["AckStatusText"]);
            // MessageBox("NEUSPJEŠNO poslan RAČUN prema FINA-i!");
            exit;
        }
    }catch(ex){
        MessageBox("Nepoznata greška:\n" + ex);
        LogException(ex); // !!!
        exit;
    }
}

function GetListMER(){
    // statusId = 40; // sent(and received)
    statusId = 30; // sent(not received)
    jsonPayload = '{"Username": "' + ERAC_USER + 
                    '", "Password": "' + ERAC_PASS + 
                    '", "CompanyId": "' + companyOIB + 
                    '", "SoftwareId": "' + ERAC_DESC + 
                    '", "StatusId": "' + statusId + 
                    '"}';
            
    try {
        apiUrl = ERAC_SERVER + "apis/v2/queryinbox";
        jsonResponse = WebRequest("POST", apiUrl, jsonPayload, "", "GetListMERSuccess", "GetListMERFailure", "application/json", null, 1000 * 20, false);
    } catch (ex) {
        MessageBox("Greška prilikom API poziva: " + ex);
        // !!! LOG !!!
        exit;
    }
}

function GetListMERSuccess(trackingId, responseCode, res) {
    MSG("MERSuccess"); // REMOVE

    try{
        LogResponse(responseCode, res);     

        res = res.ReplaceAndTrim("[", "", "]", "");
        resParts = res.Split("},{");

        for(i = 0; i < Size(resParts); i++){
            if(i == 0){
                resParts[i] = resParts[i] + "}";
            }
            elif(i == Size(resParts) - 1){
                resParts[i] = "{" + resParts[i];
            }else{
                resParts[i] = "{" + resParts[i] + "}";
            }

            racunObject = DeserializeJson(resParts[i]);
            
            AddRacunToArrays(
                racunObject["SenderBusinessName"],
                racunObject["SenderBusinessNumber"],
                "2025-01-01", // !!!
                "2025-01-01", // !!!
                racunObject["DocumentNr"],
                racunObject["ElectronicId"]
            );
        }
    }
    catch(ex){
        MessageBox("MERSuccess - Greška pri parsiranju odgovora poslužitelja:\n" + ex);
        // LogNKSYELOG(); // !!! LOG !!!
        exit;
    }
}

function GetListMERFailure(trackingId, responseCode, res) {
    MSG("MERFailure");

    try{
        LogResponse(responseCode, res);  
    }
    catch(ex){
        MessageBox("SendingFailure - Greška pri parsiranju odgovora poslužitelja:\n" + ex);
        // !!! LOG !!!
        exit;
    }
}


function AddRacunToArrays(supplierName, supplierId, datumIzdavanja, datumPdva, supplierInvoiceId, eRacunBrojRacuna){
    arrayDobavljac[Rbr] = supplierName;
    arrayOibDobavljaca[Rbr] = supplierId;
    arrayDatumIzdavanja[Rbr] = datumIzdavanja;
    arrayDatumPDVa[Rbr] = datumPdva;
    arrayBrojRacuna[Rbr] = supplierInvoiceId;
    if (PROVIDER == "MER" || PROVIDER == "MERDEMO") {
        arrayBrojRacunaMer[Rbr] = eRacunBrojRacuna;
    } elif (PROVIDER == "FINA" || PROVIDER == "FINADEMO") {
        arrayBrojRacunaFina[Rbr] = eRacunBrojRacuna;
    } else {
        MessageBox("Nepoznat provider: " + PROVIDER + ". Podržani su: MER, FINA, MERDEMO, FINADEMO");
        exit;
    }

    arrayRbr[Rbr] = ++Rbr;
}


//-----------------------------------------------------------

function btnPreuzmi@clicked(){
    cursor("wait");
    SetWidgetOptions("btnPreuzmi", "IsEnabled", "false");
    SetWidgetOptions("StatusLabel", "Content", "Preuzimanje...");

    AsyncCall("startDownload", "startImportCall");   
    // AsyncCall("startImport", "end");
}

function startDownload(){
    // Create incoming folder if it doesn't exist
    UR_NEW_DirectoryPath = FILESPATH + "UR\\" + "NEW\\";
    if (!Exists(UR_NEW_DirectoryPath)) {
        MkDir(UR_NEW_DirectoryPath);
    }
    if (PROVIDER == "MER" || PROVIDER == "MERDEMO") {
        GetRacuniMER();
    } elif (PROVIDER == "FINA" || PROVIDER == "FINADEMO") {
        GetRacuniFINA();
    } else {
        MessageBox("Nepoznat provider: " + PROVIDER + ". Podržani su: MER, FINA");
        exit;
    }
}

function GetRacuniFINA(){
    for(f = 0; f < Rbr; f++) {
        try{
            // MSG("Dohvaćam 1 ULAZNI račun preko FINA-e putem WSDL-a!");

            invoiceId = arrayBrojRacunaFina[f];
            xmlFilePath = UR_NEW_DirectoryPath + "FINA_UR_" + invoiceId + ".xml";
 //msg ("Preuzimam račun FINA ID: " + invoiceId + "..." + xmlFilePath);
            ack = FINA_GET_B2B_INCOMING_INVOICE(
                ERAC_SERVER + "B2BFinaInvoiceWebService/services/B2BFinaInvoiceWebService",
                ERAC_DESC, // "e-invoice" / NE "e-racun-winx" !
                CERTPATH + ERAC_USERT, // servisni certifikat
                CERTPATH + ERAC_PASST, // p12 certifikat (klijentski)
                ERAC_PASS, // password za p12 certifikat

                UUID(), // messageId
                "9934:" + companyOIB, // OIB primatelja (VLASTITI)
                invoiceId // invoiceId
            );

 // MSG("ack = " + ack);

            // MSG("ack[\"AckStatusCode\"] = " + ack["AckStatusCode"]);
            // MSG("ack[\"AckStatusText\"] = " + ack["AckStatusText"]);

            if(Contains(ack, "ErrorCode")){
                MessageBox("Greška pri preuzimanju računa " + invoiceId + ":\n" + "ack:" + "\n" + ack);
                continue;
            }

            //Save XML
            SaveFile(ack["ItemContent"], xmlFilePath);
            // savedXmlFilesList.Add(xmlFilePath);

            // Save PDF
            if(Contains(ack, "Base64PdfDocumentString")){
                Base642File(ack["Base64PdfDocumentString"], UR_NEW_DirectoryPath + "FINA_UR_" + invoiceId + ".pdf");
            }
            
            // NKSYELOG
            // !!! za FINA-u moramo postavit status računa na RECEIVING_CONFIRMED !!!
            // SET incoming invoice RECEIVING_CONFIRMED
            try{
                // MSG("Postavljam STATUS ulaznog računa " + invoiceId + " kod FINA-e putem WSDL-a!");

                ack = FINA_CHANGE_B2B_INCOMING_INVOICE_STATUS(
                    ERAC_SERVER + "B2BFinaInvoiceWebService/services/B2BFinaInvoiceWebService",
                    ERAC_DESC, // "e-invoice" / NE "e-racun-winx" !
                    CERTPATH + ERAC_USERT, // servisni certifikat
                    CERTPATH + ERAC_PASST, // p12 certifikat (klijentski)
                    ERAC_PASS, // password za p12 certifikat

                    UUID(), // messageId
                    "9934:" + companyOIB, // OIB primatelja (VLASTITI) // !!! stavit pravi OIB iz baze
                    invoiceId, // invoiceId
                    "RECEIVING_CONFIRMED"//, // newStatusCodeString
                    // "", // codeReasonString
                    // "" // note
                );

                 //MSG("ackStatus = " + ack);
            
                // MSG("ack[\"AckStatusCode\"] = " + ack["AckStatusCode"]);
                // MSG("ack[\"AckStatusText\"] = " + ack["AckStatusText"]);

            }catch(ex){
                MessageBox("Promjena statusa računa - Nepoznata greška:\n" + ex);
                LogException(ex);
            }
        }catch(ex){
            MessageBox("Račun " + invoiceId + "\nNepoznata greška:\n" + ex);
            LogException(ex); // !!! 
        }
    }
}

function GetRacuniMER(){
    for(h = 0; h < Rbr; h++) {
        try{
            // MSG("Dohvaćam 1 ULAZNI račun preko FINA-e putem WSDL-a!");

            invoiceId = arrayBrojRacunaMer[h];
            // trackingId = "MER_UR_" + racunObject["ElectronicId"] + "_" + racunObject["DocumentNr"] + "_" + racunObject["SenderBusinessNumber"]; // + "_" + racunObject["SenderBusinessName"];
            trackingId = "MER_UR_" + invoiceId;

            jsonPayload = '{"Username": "' + ERAC_USER + '", "Password": "' + ERAC_PASS + '", "CompanyId": "' + companyOIB + '", "SoftwareId": "' + ERAC_DESC + '", "ElectronicId": "' + invoiceId + '"}';

            WebRequest("POST", ERAC_SERVER + "apis/v2/receive", jsonPayload, trackingId, "MERReceiveRacunSuccess", "MERReceiveRacunFailure", "application/json", null, 1000 * 20, false);           
        }catch(ex){
            MessageBox("Račun " + invoiceId + "\nNepoznata greška:\n" + ex);
            LogException(ex); // !!! 
        }
    }    
}

function MERReceiveRacunSuccess(trackingId, responseCode, res) {
    MSG("MERReceiveRacunSuccess");
    // MSG("MERReceiveSuccess" + "\n" + XmlToDict(res));
    try{
        LogResponse(responseCode, res);

        xmlFilePath = UR_NEW_DirectoryPath + trackingId + ".xml";
        SaveFile(res, xmlFilePath);
        // savedXmlFilesList.Add(xmlFilePath);
    }catch(ex){
        MessageBox("MERReceiveRacunSuccess - Greška pri parsiranju odgovora poslužitelja:\n" + ex);
        // !!! LOG !!!
    }
    
}

function MERReceiveRacunFailure(trackingId, responseCode, res) {
    MSG("MERReceiveRacunFailure");
    try{
        LogResponse(responseCode, res);  
    }
    catch(ex){
        MessageBox("MERReceiveRacunFailure - Greška pri parsiranju odgovora poslužitelja:\n" + ex);
        // !!! LOG !!!
    }
}


//-----------------------------------------------------------

function startImportCall(){
    AsyncCall("startImport", "end");
}

function startImport(){
    cd(UR_NEW_DirectoryPath);
    listOfXmls = FindFiles("*.xml");

    //MSG("LIST: " + listOfXmls);
    // MSG(Size(listOfXmls));

    // for(xmlCounter = 0; xmlCounter < Size(listOfXmls); xmlCounter++){
    for(xmlCounter = 0; xmlCounter < 1; xmlCounter++){
        msg("IMPORTING: " + listOfXmls[xmlCounter]);
        xmlFilePath = listOfXmls[xmlCounter];
        MemoX = ""; //memo u kojega spremamo one podatke iz xml računa koje želimo prikazati korisniku prilikom uvoza

        xmlFilenameWithoutExtension = parsefile(xmlFilePath, "pfName");
        if(xmlFilenameWithoutExtension.StartsWith("FINA_UR_")){
            currentInvoiceId = xmlFilenameWithoutExtension.Replace("FINA_UR_", "");
        }elif(xmlFilenameWithoutExtension.StartsWith("MER_UR_")){
            currentInvoiceId = xmlFilenameWithoutExtension.Replace("MER_UR_", "");
        }else{
            currentInvoiceId = "";
        }

        importUBLXmlFromDict(ReadAllText(listOfXmls[xmlCounter]), currentInvoiceId, xmlFilenameWithoutExtension);

    }
    msg("Broj preuzetih XML računa sa servera posrednika: " + rBr +"\n\nBroj importiranih računa u bazu: " + xmlCounter);
}

// New main import function using XmlToDict
//function importUBLXmlFromDict(xmlContent, xmlFilePath = "") {
function importUBLXmlFromDict(xmlContent, _invoiceId, xmlFilenameWithoutExtension) {
    try {

        // Create incoming folder if it doesn't exist
        UR_IMPORTED_DirectoryPath = FILESPATH + "UR\\" + "IMPORTED\\" + xmlFilenameWithoutExtension + "\\";
        if (!Exists(UR_IMPORTED_DirectoryPath)) {
            MkDir(UR_IMPORTED_DirectoryPath);
        }

        //move VANJSKI pdf (if exists) to IMPORTED folder
        pdfPathInNEW = UR_NEW_DirectoryPath + xmlFilenameWithoutExtension + ".pdf";
        pdfPathInIMPORTED = UR_IMPORTED_DirectoryPath + "p0.pdf";
        if(Exists(pdfPathInNEW)){
            try{
                Move(pdfPathInNEW, pdfPathInIMPORTED);
            }
            catch(aa){
                MessageBox("Greška prilikom premještanja PDF datoteke: " + aa);
            }
        }
        



        documentDict = XmlToDict(xmlContent);
        
        documentKeys = documentDict.Keys;
        documentType = documentKeys[0];

        invoiceDict = documentDict[documentType];


        NKPR_GL_POSRED = _invoiceId;
        
        // // //************
        // MSG(documentDict[documentType]["InvoiceLine"]); 


        // linesArray = documentDict[documentType]["InvoiceLine"];
        // MSG(linesArray);


        // MSG(documentDict[documentType]["InvoiceLine"]); 
        // // //************


        // MSG(documentDict["Invoice"]["InvoiceLine"]);

        if (invoiceDict == null || Size(invoiceDict) == 0) {
            MessageBox("Greška prilikom parsiranja XML-a u Dictionary");
            return false;
        }
        
        // Determine document type from dictionary structure
        docType = GetDocumentTypeFromDict(invoiceDict);
        if (docType == "") {
            MessageBox("Nepoznat tip dokumenta u XML datoteci");
            return false;
        }
        
        // Extract header information from dictionary
        if (!ExtractHeaderDataFromDict(invoiceDict, docType)) {
            MessageBox("Greška prilikom izvlačenja podataka zaglavlja");
            return false;
        }
        //   if (NKPR_GL_ESD"] == "") {NKPR_GL_ESD"] = NKPR_GL_INVDTE"];} 
        // Validate fiscal year before proceeding
        //if (!ValidateFiscalYear(NKPR_GL_ESD"])) {
        if (!ValidateFiscalYear(NKPR_GL_ESD)) {
            MessageBox("Račun se ne može importirati jer datum ESD (" + NKPR_GL_ESD + ") ne pripada fiskalnoj godini " + KPSY_FISCAL_YR + ". Račun će biti premješten u arhivu.");
            return "FISCAL_YEAR_MISMATCH";
        }
        //msg ("ESD: " + NKPR_GL_ESD + " FISCAL YR: " + KPSY_FISCAL_YR);
        // Extract line items from dictionary
        // lineItems = ExtractLineItemsFromDict(invoiceDict, docType);

        ExtractLineItemsFromDict(invoiceDict, docType);
        if (lineItems == null) {
            MessageBox("Greška prilikom izvlačenja stavki računa");
            return false;
        }
        
        
        //return;   
    
        // MSG("99999999" + lineItems);

        // Begin database transaction
        //BeginTransaction();
        
        try {
            // Import header data to NKNAERGL table
            //msg ("0000: xmlFilePath: " + xmlFilePath); 
            invNum = ImportHeaderDataToERGL(docType);
            if (invNum == 0) {
                throw "Greška prilikom unosa zaglavlja računa";
            }
            // Import line items to NKNAERLN table
            if (!ImportLineItemsToERLN(invNum, lineItems)) {
                throw "Greška prilikom unosa stavki računa";
            }
            // Log to NKSYELOG
            //msg("2222: xmlFilePath: " + xmlFilePath);    
            // LogToNKSYELOG(invNum, xmlFilePath, "IMPORT_SUCCESS");
            
            // Commit transaction
            //CommitTransaction();
            

            // Move XML to IMPORTED folder
            Move(UR_NEW_DirectoryPath + xmlFilenameWithoutExtension + ".xml", UR_IMPORTED_DirectoryPath + xmlFilenameWithoutExtension + ".xml");
            
            
            //MessageBox("UBL XML račun je uspješno uvezen!\nBroj računa: " + invNum);


            // LogNKSYELOG("P", invNum, currentInvoiceId);

            return invNum;
            
        } catch (error) {
            // Rollback transaction on error
            //RollbackTransaction();
            //msg("4444: xmlFilePath: " + xmlFilePath + " ERROR: " + error);       
            // LogToNKSYELOG(0, xmlFilePath, "IMPORT_FAILURE: " + error);
            MessageBox("Greška prilikom unosa u bazu podataka: " + error);
            return false;
        }
        
    } catch (error) {
        MessageBox("Greška prilikom uvoza XML datoteke: " + error);
        return false;
    }
}

// Determine document type from Dictionary structure
function GetDocumentTypeFromDict(invoiceDict) {
    // Check which root element exists in dictionary
    if (Contains(invoiceDict, "Invoice")) { return "S"; }
    if (Contains(invoiceDict, "CreditNote")) { return "O"; }
    if (Contains(invoiceDict, "DebitNote")) { return "T"; }
    
    // Check if we have direct access to elements (flat structure)
    if (Contains(invoiceDict, "ID") && Contains(invoiceDict, "InvoiceTypeCode")) { return "S"; }
    if (Contains(invoiceDict, "ID") && Contains(invoiceDict, "CreditNoteTypeCode")) { return "O"; }
    if (Contains(invoiceDict, "ID") && Contains(invoiceDict, "DebitNoteTypeCode")) { return "T"; }
    
    return "";
}

// Extract header data from Dictionary
function ExtractHeaderDataFromDict(invoiceDict, docType){
    try 
    {
        NKPR_GL_SHPA1 = "";
        NKPR_GL_SHPCOD = "";
        NKPR_GL_SHPCTY = "";
        NKPR_GL_SHPZIP = "";
        NKPR_GL_SHPST = "";
        NKPR_GL_SHPNME = "";
        NKPR_GL_SIF_PL = "";
        NKPR_GL_MODEL = "";
        NKPR_GL_POZIV = "";
        NKPR_GL_RZRVA1 = "";
        NKPR_GL_DESC = "";
        NKPR_GL_OZNAKA = "";
        NKPR_GL_DATPRI = "1900-01-01";
        NKPR_GL_TIMECR = now("HH:mm:ss").toString();
        NKPR_GL_DVO = "1900-01-01";
        NKPR_GL_INVDTE = now("yyyy-MM-dd").toString();
        NKPR_GL_NOKAM = 0;
        NKPR_GL_ROKPL = 0;
        NKPR_GL_ESD = "1900-01-01";
        NKPR_GL_SIFDVZ = "";
        NKPR_GL_CUSCOD = "";
        NKPR_GL_CUSNME = "";
        NKPR_GL_CUSA1 = "";
        NKPR_GL_CUSCTY = "";
        NKPR_GL_CUSZIP = 0;
        NKPR_GL_DRZAVA = "";
        NKPR_GL_CUSST = "";
        NKPR_GL_JMBG = "";
        NKPR_GL_SUBTOT = 0;
        NKPR_GL_TOTAL = 0;
        NKPR_GL_TAXAMT = 0;
        NKPR_GL_REZ3 = 0;

        // Get the root document data (handle nested or flat structure)
        docData = invoiceDict;
        if (docType == "S" && Contains(invoiceDict, "Invoice")) {
            docData = invoiceDict["Invoice"];
        } elif (docType == "O" && Contains(invoiceDict, "CreditNote")) {
            docData = invoiceDict["CreditNote"];
        } elif (docType == "T" && Contains(invoiceDict, "DebitNote")) {
            docData = invoiceDict["DebitNote"];            }
            
        // Basic invoice information
        glDesc = docData["ID"]; //broj računa od dobavljača
        
        if(glDesc.length > 40){
            NKPR_GL_DESC = Substring(glDesc, 0, 40);
            memoX += "Originalni broj računa dobavljača: " + glDesc + "\n";
        }else{
            NKPR_GL_DESC = glDesc;
        }
            
        //provjeriti kasnije kad imamo i OIB dobavljača, u NKNAERGL da li je taj broj već unesen/preuzet
        //sada još uzmimo copyIndictIndicator iz računa ako postoji
        copyIndicator = "";
        if (Contains(docData, "CopyIndicator")) {
            copyIndicator = docData["CopyIndicator"];
        }
        NKPR_GL_OZNAKA = docType;
        NKPR_GL_DATPRI = docData["IssueDate"];
        NKPR_GL_DVO = docData["IssueDate"];
        NKPR_GL_NOKAM = 0;
        if (Contains(docData, "DueDate")){
            //tu staviti matematiku za datum dospijeća: duedate-issuedate=nokam kao broj dana, a dvo je isti kao i datum issuedate
            dueDate = docData["DueDate"];
            dueDateDateTime = DateTime(dueDate, "yyyy-MM-dd");
            datpriDateTime = DateTime(NKPR_GL_DATPRI, "yyyy-MM-dd");
            dateDiff = Math.Trunc(DateTimeToDouble(dueDateDateTime)) - Math.Trunc(DateTimeToDouble(datpriDateTime));
            NKPR_GL_NOKAM = dateDiff; // !!! hardcoded 30 days for now, TREBA POPRAVITI!!!
        } else{
            NKPR_GL_DVO = docData["IssueDate"].toString();
            NKPR_GL_NOKAM = 30;
        }   
           
        if (Contains(docData, "TaxPointDate")) {
            NKPR_GL_ESD = docData["TaxPointDate"];
            //GL_ESD = docData["TaxPointDate"].toString();
        }else{
            NKPR_GL_ESD = docData["IssueDate"];
            //GL_ESD = docData["IssueDate"].toString();
        }

        // Currency
        NKPR_GL_SIFDVZ = docData["DocumentCurrencyCode"];
        //sifdvz = docData["DocumentCurrencyCode"].toString();
        // Supplier information from AccountingSupplierParty
        suppParty = docData["AccountingSupplierParty"];
        if (suppParty != null && suppParty != "") {
            suppPartyData = suppParty;
            if (Contains(suppParty, "Party")) {
                suppPartyData = suppParty["Party"];
            }

            // Supplier OIB/GLN
            OIBSupp = "";
            GLNSupp = "";

            companyIDEndpointID = suppPartyData["EndpointID"]; // npr 12345678903
            if(companyIDEndpointID["@attributes"]["schemeID"] == "9934"){
                OIBSupp = companyIDEndpointID["@text"];
            } elif(companyIDEndpointID["@attributes"]["schemeID"] == "0088"){
                GLNSupp = companyIDEndpointID["@text"];

                if(Contains(suppPartyData, "PartyIdentification")){// npr.: OIB 9934:12345678903 ili možda GLN 0088:12345678
                    companyIDPartyIdentificationID = suppPartyData["PartyIdentification"]["ID"];
                    refNumbers = companyIDPartyIdentificationID.split(":");
                    refNum = refNumbers[0].trim();
                    refOIB = refNumbers[1].trim();
                    if(refNum == "9934"){
                        OIBSupp = refOIB;
                    } elif(refNum == "0088"){
                        GLNSupp = refOIB;

                        if(OIBSupp == ""){
                            if(Contains(suppPartyData, "PartyTaxScheme")){
                                compId = suppPartyData["PartyTaxScheme"]["CompanyID"]; // npr.: OIB 9934:12345678903 ili možda GLN 0088:12345678
                                OIBSupp = compId.Replace("HR", "");
                            }
                            else{
                                MessageBox("Nije moguće odrediti OIB dobavljača za račun " + NKPR_GL_DESC + ".");
                            }
                        }
                    }
                }
            }

            
            // Supplier name
            suppName= "";
            if (Contains(suppPartyData, "PartyLegalEntity")) {
                suppName = suppPartyData["PartyLegalEntity"]["RegistrationName"];
            } else {
                //suppName = suppPartyData["PartyLegalEntity"]["CompanyName"];
                //find name from NKSCPART
            }
            NKPR_GL_CUSNME = "";
            if (suppName != "") {
                NKPR_GL_CUSNME = suppName;
            }  

            //odrediti OIB dobavljača iz /Invoice/cac:AccountingSupplierParty/cac:Party/cac:PartyTaxScheme/cbc:CompanyID
            if (Contains(suppPartyData, "PartyTaxScheme")) {
                partyTaxScheme = suppPartyData["PartyTaxScheme"];
                if (Contains(partyTaxScheme, "CompanyID")) {
                    OIBSupp = partyTaxScheme["CompanyID"];
                    if (OIBSupp.length > 11) {
                        OIBSupp = Substring(OIBSupp, OIBSupp.length - 11, 11); //uzeti zadnjih 11 znakova
                    }
                }
            }
            
            //tu sad imamo OIB dobavljača i broj računa dobavljača; sada provjeriti da li je taj račun već unesen za tog dobavljača
            sqlQueryString = "select NKPR_GL_JMBG, NKPR_GL_DESC from " + strtrim(databaseName) + ".dbo.NKNAERGL WHERE NKPR_GL_JMBG = '" + OIBSupp + "' AND NKPR_GL_DESC = '" + NKPR_GL_DESC + "'";
            sqlOIBInvoicenum = sqlQuery(sqlQueryString);
            if (size(sqlOIBInvoicenum) > 1)
            {
                if(copyIndicator != "true"){
                    //ako je copyIndicator ne postoji ili je false, onda je to kopija računa i dozvoliti unos
                    //ako nije, onda javiti da je račun već unesen
                }else{
                    //tu bi sada trebalo u originalni račun pod tim brojem spremiti u MemoX da je taj račun dobio kopiju i koji je broj te kopije
                    memoX += "Račun s OIB-om dobavljača " + OIBSupp + " i brojem računa dobavljača " + glDesc + " je već unesen u bazu pod brojem računa: " + sqlOIBInvoicenum[1][0].trim() + ". Došla je kopija računa.\n";
                    return;
                }
            }

            // Supplier address
            if (Contains(suppPartyData, "PostalAddress")) { 
                suppAddress = suppPartyData["PostalAddress"];
                if (suppAddress != null && suppAddress != "") {
                    if (Contains(suppAddress, "StreetName")) {NKPR_GL_CUSA1 = suppAddress["StreetName"]};
                    if (Contains(suppAddress, "CityName")) {NKPR_GL_CUSCTY = suppAddress["CityName"]};
                    if (Contains(suppAddress, "PostalZone")) {NKPR_GL_CUSZIP = suppAddress["PostalZone"]};
                    if (Contains(suppAddress, "Country")) {NKPR_GL_CUSST = suppAddress["Country"]["IdentificationCode"]};
                    if (Contains(suppAddress, "Country")) {NKPR_GL_DRZAVA = suppAddress["Country"]["IdentificationCode"]};
                }
            }
        }

        //msg("11121: "+companyIDPartyIdentificationID);
        NKPR_GL_CUSCOD = "";
        if (OIBSupp != "") { 
            // OIB
            // NKSCPART - nađi dobavljača po OIB-u/GLN-u i uzmi šifru dobavljača
            // ako ne postoji, kreiraj novog dobavljača
            sqlQueryString = "select NKSC_PARTCODE, NKSC_PARTNAME, NKSC_RO, NKSC_ADD1, NKSC_CITY, NKSC_ZIP, NKSC_drzava, NKSC_SIFRA  from " + strtrim(databaseName) + ".dbo.NKSCPART WHERE NKSC_SIFRA = '" + OIBSupp + "'";
            try
            {
                sqlPartner = sqlQuery(sqlQueryString);
            }
            catch(ex)
            {
                MessageBox("Greška čitanja NKSCPART:\n" + ex);
                // Ovo je novi dobavljač, treba ga unijeti ili prekinuti unos ovog računa i dati poruku na ekranu
                //exit;
            }
        } elif (GLNSupp != "") { // GLN
            // NKSCPART - nađi dobavljača po OIB-u/GLN-u i uzmi šifru dobavljača
            // ako ne postoji, kreiraj novog dobavljača
            sqlQueryString = "select NKSC_PARTCODE, NKSC_PARTNAME, NKSC_RO, NKSC_ADD1, NKSC_CITY, NKSC_ZIP, NKSC_drzava, NKSC_SIFRA  from " + strtrim(databaseName) + ".dbo.NKSCPART WHERE NKSC_SOP = '" + GLNSupp + "'";
            try
            {
                sqlPartner = sqlQuery(sqlQueryString);
            }
            catch(ex)
            {
                MessageBox("Greška čitanja NKSCPART:\n" + ex);
                // Ovo je novi dobavljač, treba ga unijeti ili prekinuti unos ovog računa i dati poruku na ekranu
                //exit;
            }
        } else {
            //Ovo je nepodržano za sada, staviti poruku i prekinuti unos ovog računa
            MessageBox("Nepodržani identifikator dobavljača: " + companyIDPartyIdentificationID + ". Račun neće biti uvezen.");
            return;
        }

        if (size(sqlPartner) > 1)
        {
            /*  
                cuscod = sqlPartner[1][0].trim(); //     NKSC_PARTCODE
                partname = sqlPartner[1][1].trim(); //     NKSC_PARTNAME
                ro = sqlPartner[1][2].trim(); //     NKSC_ro    
                cusa1 = sqlPartner[1][3].trim(); //  NKSC_ADD1
                cuscty = sqlPartner[1][4].trim(); // NKSC_CITY
                cuszip = sqlPartner[1][5]; // NKSC_ZIP
                drzava = sqlPartner[1][6].trim(); // NKSC_drzava
                jmbg = sqlPartner[1][7].trim(); // NKSC_sifra
            */
            //Izgleda bug u CSCS_WPF - ako preuzme vrijednosti iz sqlPartner resultseta, izbriše cijeli dictionary headerData???
            //Rješenje je da ih prvo spremimo u varijable, pa onda iz njih u headerData
            NKPR_GL_CUSCOD = sqlPartner[1][0].trim(); //     NKSC_PARTCODE
            NKPR_GL_CUSNME = sqlPartner[1][1].trim(); //     NKSC_PARTNAME
            NKPR_GL_ro = sqlPartner[1][2].trim(); //     NKSC_ro
            NKPR_GL_CUSA1 = sqlPartner[1][3].trim(); //  NKSC_ADD1
            NKPR_GL_CUSCTY = sqlPartner[1][4].trim(); // NKSC_CITY
            NKPR_GL_CUSZIP = sqlPartner[1][5]; // NKSC_ZIP
            NKPR_GL_DRZAVA = sqlPartner[1][6].trim(); // NKSC_drzava
            NKPR_GL_JMBG  = sqlPartner[1][7].trim(); // NKSC_sifra

        }else{
            //msg( "Ovo je novi partner! Molim da ga otvorite u matičnim podacima partnera:\n" + 
            //return;
        }   

        if (OIBSupp != "") {
            NKPR_GL_JMBG = OIBSupp;
        } elif (GLNSupp != "") {
            MemoX += "GLN: " + GLNSupp + "\n";
        }else {
            return;
        }

        // Customer information from AccountingCustomerParty
        //this is own company data
        custParty = docData["AccountingCustomerParty"];
        if (custParty != null && custParty != "") {
            custPartyData = custParty;
            if (Contains(custParty, "Party")) {
                custPartyData = custParty["Party"];
            }


            // Customer OIB/GLN
            OIBCust = "";
            GLNCust = "";

            companyIDEndpointID = custPartyData["EndpointID"]; // npr 12345678903
            if(companyIDEndpointID["@attributes"]["schemeID"] == "9934"){
                OIBCust = companyIDEndpointID["@text"];
            } elif(companyIDEndpointID["@attributes"]["schemeID"] == "0088"){
                GLNCust = companyIDEndpointID["@text"];

                if(Contains(custPartyData, "PartyIdentification")){// npr.: OIB 9934:12345678903 ili možda GLN 0088:12345678
                    companyIDPartyIdentificationID = custPartyData["PartyIdentification"]["ID"];
                    refNumbers = companyIDPartyIdentificationID.split(":");
                    refNum = refNumbers[0].trim();
                    refOIB = refNumbers[1].trim();
                    if(refNum == "9934"){
                        OIBCust = refOIB;
                    } elif(refNum == "0088"){
                        GLNCust = refOIB;

                        if(OIBCust == ""){
                            if(Contains(custPartyData, "PartyTaxScheme")){
                                compId = custPartyData["PartyTaxScheme"]["CompanyID"]; // npr.: OIB 9934:12345678903 ili možda GLN 0088:12345678
                                OIBCust = compId.Replace("HR", "");
                            }
                            else{
                                MessageBox("Nije moguće odrediti OIB kupca iz računa " + NKPR_GL_DESC + ".");
                            }
                        }
                    }
                }
            }

            if(OIBCust == ""){
                MessageBox("Nije moguće odrediti OIB kupca iz računa " + NKPR_GL_DESC + ". Račun neće biti uvezen.");
                return;
            }
            
            if (CompanyOIB != OIBCust){
                MessageBox("OIB kupca u računu (" + OIBCust + ") ne odgovara OIB-u naše tvrtke (" + CompanyOIB + "). Račun neće biti uvezen.");
                return;
            }

        }


        // Delivery information
        if (Contains(docData, "Delivery")) {
            delivery = docData["Delivery"];
            if (delivery != null && delivery != "") {
                if (Contains(delivery, "DeliveryLocation")) {
                    deliveryLocation = delivery["DeliveryLocation"];
                    if (deliveryLocation != null && deliveryLocation != "") {
                        if (Contains(deliveryLocation, "ID")) {
                            deliveryID = deliveryLocation["ID"];
                        } else {
                            deliveryID = "";
                        }
                        if (deliveryID != "") {
                            // Check if it's GLN (13 characters) or internal code
                            if (deliveryID.length == 13) {
                                //tu trebamo provjerit samo da li je to mjesto isporuke predviđeno kod nas u NKSPADRS!!!!
                                //NKPR_AD_GLN = deliveryID;
                            } else {
                                NKPR_GL_SHPCOD = deliveryID;
                            }
                        }
                        // Delivery address
                        if (Contains(deliveryLocation, "Address")) {
                            deliveryAddr = deliveryLocation["Address"];
                        } else {
                            deliveryAddr = {};
                        }
                        if (deliveryAddr != null && deliveryAddr != "") {
                            if (Contains(deliveryAddr, "StreetName")) {NKPR_GL_SHPA1 = deliveryAddr["StreetName"]};
                            if (Contains(deliveryAddr, "CityName")) {NKPR_GL_SHPCTY = deliveryAddr["CityName"]};
                            if (Contains(deliveryAddr, "PostalZone")) {NKPR_GL_SHPZIP = deliveryAddr["PostalZone"]};
                            if (Contains(deliveryAddr, "Country")) {NKPR_GL_SHPST = deliveryAddr["Country"]["IdentificationCode"]};
                        }
                    }
                }
            
                // Delivery party
                if (Contains(delivery, "DeliveryParty")) {
                    deliveryParty = delivery["DeliveryParty"];
                    if (deliveryParty != null && deliveryParty != "") {
                        NKPR_GL_SHPNME = deliveryParty["PartyName"]["Name"];
                    }
                } else {
                    deliveryParty = {};
                }
            }
        }
        
        
        // Payment information
        paymentMeans = docData["PaymentMeans"];
        xmlPaymentMeansCode = "";
        if (paymentMeans != null && paymentMeans != "") {
            // Get PaymentMeansCode from XML (e.g., "30", "42", etc.)
        //    xmlPaymentMeansCode = paymentMeans["PaymentMeansCode"]; //[#text]; POPRAVITI!!!
            if (Contains(paymentMeans, "PaymentMeansCode")) {
                paymentMeansCodeData = paymentMeans["PaymentMeansCode"];
                if (typeof(paymentMeansCodeData) == "dictionary") {
                    xmlPaymentMeansCode = paymentMeansCodeData["#text"];
                } else {
                    xmlPaymentMeansCode = paymentMeansCodeData;
                }
            }
            xmlPaymentMeansCode = "";
            // Convert XML PaymentMeansCode to internal KPKSVRPL code
            // Reverse process from wxeracun.cscs
            NKPR_GL_SIF_PL = "";
            if (xmlPaymentMeansCode != "") {
                // Query KPKSVRPL table to find matching internal code
                // KPKS_PL_NAZIV2 contains the UBL code (e.g., "30", "42")
                sql_payment = "SELECT KPKS_PL_SIF_PL FROM " + databaseName + ".dbo.KPKSVRPL WHERE SUBSTRING(KPKS_PL_NAZIV2,1, 2) = @p1;";
                sqlParams = {};
                sqlParams.Add({"@p1", xmlPaymentMeansCode});
                paymentRes = sqlQuery(sql_payment, sqlParams);
                if (Size(paymentRes) >= 2) {
                    NKPR_GL_SIF_PL = paymentRes[1][0].trim();
                    //msg("Payment means code converted: XML=" + xmlPaymentMeansCode + " -> Internal=" + NKPR_GL_SIF_PL);
                } else {
                    // If no match found, use default or log warning
                    //msg("WARNING: No matching payment means code found in KPKSVRPL for XML code: " + xmlPaymentMeansCode);
                    NKPR_GL_SIF_PL = xmlPaymentMeansCode; // Or set a value from XML directly
                }
            }

            ziroFound = false;
            if (NKPR_GL_CUSCOD != "") {
                sql_bank = "SELECT NKSC_ZR_KONTO, NKSC_ZR_NAZIV, NKSC_ZR_BANKA FROM " + databaseName + ".dbo.NKSCZIRO WHERE NKSC_ZR_CODE = @p1;";
                sqlParams = {};
                sqlParams.Add({"@p1", NKPR_GL_CUSCOD});
                bankRes = sqlQuery(sql_bank, sqlParams);
                if (Size(bankRes) >= 2) {
                    
                    for(bankResCounter = 0; bankResCounter < Size(bankRes); bankResCounter++){
                        NKSC_ZR_KONTO = bankRes[bankResCounter][0].trim();
                        NKSC_ZR_NAZIV = bankRes[bankResCounter][1].trim();
                        NKSC_ZR_BANKA = bankRes[bankResCounter][2].trim();
                        if (contains(paymentMeans,"PayeeFinancialAccount")) {
                            pfe = paymentMeans["PayeeFinancialAccount"];
                            pfeId = pfe["ID"];
                            if(Contains(pfeId, "@attributes")){
                                pfeId = pfeId["@text"];
                            }else{
                                // pfeId = pfeId;
                            }

                            if (NKSC_ZR_KONTO.Replace(" ", "") == pfeId.Replace(" ", "")) {
                                NKPR_GL_RZRVA1 = NKSC_ZR_BANKA;
                                ziroFound = true;
                                break;
                            }
                        }
                    }

                    if(ziroFound == false){
                        NKPR_GL_SIGNATU = pfeId.Replace(" ", "");
                    }
                }
            } else {
                if (contains(paymentMeans,"PayeeFinancialAccount")) {
                    paymentAccount = paymentMeans["PayeeFinancialAccount"];
                    pfeId = paymentAccount["ID"];
                    if(Contains(pfeId, "@attributes")){
                        pfeId = pfeId["@text"];
                    }
                    // else{
                    //     pfeId = pfeId;
                    // }
                    NKPR_GL_SIGNATU = pfeId;
                }
            }

            if (Contains(paymentMeans, "PaymentID")) {
                paymentID = paymentMeans["PaymentID"];
                NKPR_GL_MODEL = Substring(paymentID, 2, 2);
                //if (Contains(paymentID, " ")) {
                //    paymentParts = paymentID.split(" ");
                //    if (Size(paymentParts) > 1) {

                //        NKPR_GL_POZIV = paymentParts[2].trim();
                //    }
                //} else {
                    NKPR_GL_POZIV = Substring(paymentID, 5, paymentID.length - 4);
            }
        }
        
        
        // Monetary totals
        legalMonTotal = docData["LegalMonetaryTotal"];
        if (legalMonTotal != null && legalMonTotal != "") {
            //NKPR_GL_LINETOTAL = ParseDecimal(legalMonTotal["LineExtensionAmount"]);
            NKPR_GL_SUBTOT = ParseDecimal(legalMonTotal["TaxExclusiveAmount"]);
            NKPR_GL_TOTAL = ParseDecimal(legalMonTotal["TaxInclusiveAmount"]);
            NKPR_GL_TAXAMT = NKPR_GL_TOTAL - NKPR_GL_SUBTOT;
        }
        
        
        // Notes
        if (Contains(docData, "Note")) {
            note = docData["Note"];
            if (note != "") {
                /*
                // Parse referenced invoices from note, za slučaj kada dobavljač šalje račun koji je napravljen sa našim programom Asconto ERP
                refStartPos = IndexOf(note, "#REF(");
                if (refStartPos >= 0) {
                    refEndPos = IndexOf(note, ")", refStartPos);
                    if (refEndPos >= 0) {
                        refContent = Substring(note, refStartPos + 5, refEndPos - refStartPos - 5);
                        refNumbers = refContent.Split(","); // Split by comma 
                        if (Size(refNumbers) == 1) {
                            NKPR_GL_REZ3 = refNumbers[1].trim();
                        } elif (Size(refNumbers) > 1){
                            //put all data to MEMO field separated by comma
                            MemoX += "Referencirani računi: ";
                        } else {
                            //no valid ref found
                        }
                    }
                }
                */
                //tu sad treba spremit cijeli note u MemoH ili MemoF ili u linije ili negdje drugdje ako treba
            }
        }

        // Extract and save notes to NKNAOPIS table
        ExtractAndSaveNotes(docData);

        // Extract and save attachments to disk and NKSYPICT table
        ExtractAndSaveAttachments(invoiceDict, docType);

        // Billing references
        if (Contains(docData, "BillingReference")) {
            billingRef = docData["BillingReference"];
            billingRefID = billingRef["InvoiceDocumentReference.ID"];
            if (billingRefID != "" && NKPR_GL_REZ3 == "") {
                NKPR_GL_REZ3 = ParseInvoiceNumber(billingRefID);
            }
        } else {
            billingRef = {};
        }

        return true;
        
    } catch (error) {
        MessageBox("Greška prilikom izvlačenja podataka zaglavlja: " + error);
        return null;
    }
}

// Add this function after ExtractHeaderDataFromDict function

// -----------------------------------------------------------
// Save note to NKNAOPIS table and return reference number
// -----------------------------------------------------------
function SaveNoteToNKNAOPIS(noteText) {
    try {
        if (noteText == "" || noteText == null) {
            return 0;
        }
        
        // Get next available KPPR_OP_BROJ
        sql_max_note = "SELECT ISNULL(MAX(KPPR_OP_BROJ), 0) AS maxNum FROM " + databaseName + ".dbo.NKNAOPIS";
        maxRes = sqlQuery(sql_max_note);
        
        nextNoteNum = 1;
        if (Size(maxRes) >= 2) {
            nextNoteNum = maxRes[1][0] + 1;
        }
        
        // Split note text into chunks of 75 characters
        noteLength = noteText.length;
        chunkSize = 75;
        lineNum = 1;
        startPos = 0;
        
        while (startPos < noteLength) {
            // Calculate chunk length (75 chars or remaining text if less)
            remainingLength = noteLength - startPos;
            currentChunkSize = (remainingLength > chunkSize) ? chunkSize : remainingLength;
            
            // Extract chunk
            chunk = Substring(noteText, startPos, currentChunkSize);
            
            // Insert chunk into KPPROPIS
            sql_insert_note = "INSERT INTO " + databaseName + ".dbo.NKNAOPIS (KPPR_OP_BROJ, KPPR_OP_LIN, KPPR_OP_TEXT) " +
                            "VALUES (@p1, @p2, @p3);";
            sqlParams = {};
            sqlParams.Add({"@p1", nextNoteNum});
            sqlParams.Add({"@p2", lineNum});
            sqlParams.Add({"@p3", chunk});
            
            result = SqlNonQuery(sql_insert_note, sqlParams);
            
            if (result == 0) {
                throw "Failed to insert note chunk at line " + lineNum;
            }
            
            // Move to next chunk
            startPos += chunkSize;
            lineNum++;
        }
        
        msg("Note saved with reference number: " + nextNoteNum + " (" + (lineNum - 1) + " lines)");
        return nextNoteNum;
        
    } catch (error) {
        MessageBox("Greška pri spremanju napomene: " + error);
        return 0;
    }
}

// -----------------------------------------------------------
// Extract and save notes from document
// -----------------------------------------------------------
function ExtractAndSaveNotes(docData) {
    try {
        NKPR_GL_BROPIS = 0;
        NKPR_GL_BROPIS1 = 0;
        
        // Check if Note element exists
        if (!Contains(docData, "Note")) {
            return; // No notes to process
        }
        
        noteValue = docData["Note"];
        
        if (noteValue == null || noteValue == "") {
            return; // Empty note
        }
        
       // msg("=== PROCESSING NOTES ===");
        //msg("Note type: " + noteValue.type());
        
        // Handle single note (STRING or OBJECT)
        if (noteValue.type() == "STRING") {
            // Single note as simple string
            NKPR_GL_BROPIS = SaveNoteToNKNAOPIS(noteValue);
            msg("Saved first note with reference: " + NKPR_GL_BROPIS);
        }
        elif (noteValue.type() == "OBJECT" && !IsArray(noteValue)) {
            // Single note as object (might have #text)
            noteText = "";
            if (Contains(noteValue, "#text")) {
                noteText = noteValue["#text"];
            } else {
                noteText = String(noteValue);
            }
            NKPR_GL_BROPIS = SaveNoteToNKNAOPIS(noteText);
            msg("Saved first note with reference: " + NKPR_GL_BROPIS);
        }
        elif (noteValue.type() == "ARRAY") {
            // Multiple notes as array
            if (noteValue.size() > 0) {
                // First note
                firstNote = noteValue[0];
                firstNoteText = "";
                
                if (firstNote.type() == "STRING") {
                    firstNoteText = firstNote;
                } elif (Contains(firstNote, "#text")) {
                    firstNoteText = firstNote["#text"];
                } else {
                    firstNoteText = String(firstNote);
                }
                
                NKPR_GL_BROPIS = SaveNoteToNKNAOPIS(firstNoteText);
                msg("Saved first note with reference: " + NKPR_GL_BROPIS);
            }
            
            if (noteValue.size() > 1) {
                // Second note
                secondNote = noteValue[1];
                secondNoteText = "";
                
                if (secondNote.type() == "STRING") {
                    secondNoteText = secondNote;
                } elif (Contains(secondNote, "#text")) {
                    secondNoteText = secondNote["#text"];
                } else {
                    secondNoteText = String(secondNote);
                }
                
                NKPR_GL_BROPIS1 = SaveNoteToNKNAOPIS(secondNoteText);
                msg("Saved second note with reference: " + NKPR_GL_BROPIS1);
            }
            
            // If there are more than 2 notes, log a warning
            if (noteValue.size() > 2) {
                //ako ima više od va notesa, treba ih spremiti u istu tablu NKNAOPIS i na isti način, ali svaki notes treba otvorit novu liniju u NKNAERLN i referenti broj spremiti u NKPR_LN_BROPI
                msg("WARNING: Document contains " + noteValue.size() + " notes, but only first 2 were saved");
            }
        }
        
        //msg("=== NOTES PROCESSING COMPLETE ===");
        //msg("NKPR_GL_BROPIS: " + NKPR_GL_BROPIS);
        //msg("NKPR_GL_BROPIS1: " + NKPR_GL_BROPIS1);
        
    } catch (error) {
        MessageBox("Greška pri obradi napomena: " + error);
    }
}

// Extract line items from Dictionary
function ExtractLineItemsFromDict(invoiceDict, docType) {
    try {
        lineItems = {};
        // Get the root document data
        docData = invoiceDict;
        if (docType == "S" && invoiceDict.Contains("Invoice")) {
            docData = invoiceDict["Invoice"];
        } elif (docType == "R" && invoiceDict.Contains("CreditNote")) {
            docData = invoiceDict["CreditNote"];
        } elif (docType == "T" && invoiceDict.Contains("DebitNote")) {
            docData = invoiceDict["DebitNote"];
        }
        
        // Determine line element name based on document type
        lineElementName = "";
        quantityElementName = "";
        if (docType == "S") {
            lineElementName = "InvoiceLine";
            quantityElementName = "InvoicedQuantity";
        } elif (docType == "R") {
            lineElementName = "CreditNoteLine";
            quantityElementName = "CreditedQuantity";
        } elif (docType == "T") {
            lineElementName = "DebitNoteLine";
            quantityElementName = "DebitedQuantity";
        }
        
        // Get line items array
       
        // MSG("docData:\n" + docData);
        // MSG("lineElementName:\n" + lineElementName);

        // msg("docData:\n" + docData);
        // msg("lineelementName:\n" + lineelementName);
        //linesArray = docData[lineElementName]; 
        
        // linesArray = GetDictValue2(docData, lineElementName); 
        // linesArray = docData["InvoiceLine"]; 

        if(ArrayOrDict(documentDict[documentType][lineElementName]) == "array"){
            for(mmm = 0; mmm < Size(documentDict[documentType][lineElementName]); mmm++){
                // msg("LINE " + mmm + ": " + documentDict[documentType][lineElementName][mmm]);
                // lin = documentDict[documentType][lineElementName][mmm];
                // MSG("LIN: " + lin);
                
                //MSG("AAAA: " + quantityElementName+" LINE DATA: " + linesArray[i]);
                lineData = ExtractSingleLineFromDict(documentDict[documentType][lineElementName][mmm], quantityElementName);
                //MSG("Processing line " + i + ": " + lineData);
                if (lineData != null) {
                    // MSG(lineData);
                    // MSG(lineItems);
                    lineItems.Add(lineData);
                     //MSG("HHHH: " + lineItems);
                }
            }                
        }else{
            //msg("It's a dict");
            // MSG("DICT: " + documentDict[documentType][lineElementName]);

            lineData = ExtractSingleLineFromDict(documentDict[documentType][lineElementName], quantityElementName);
            if (lineData != null) {
                lineItems.Add(lineData);
            }
        }



        // MSG(documentDict[documentType][lineElementName]); 
        
        // linesArray = documentDict[documentType][lineElementName];
        // MSG(linesArray);

        // MSG(documentDict[documentType][lineElementName]); 
        

        //msg ("LINES ARRAY: " + linesArray);    
        // if (linesArray == null || linesArray == "") {
        //     return {}; // Return empty array if no lines found
        // }
        // linArrType = linesArray.type()

        //Msg("linArrType: " + linArrType);
        //OVO TREBA RIJEŠIT - NE VRAĆA BROJ LINIJA KAKO TREBA, pa ne odradi sve linije i tu negdje pada u grešku
        // if (linArrType == "ARRAY") {
        //     //msg ("MULTIPLE LINES DETECTED");
        //     // Handle multiple lines
        //     lineItems = {};
            
        //     // Multiple lines
        //     for (i = 0; i < linesArray.size(); i++) {
        //         //MSG("AAAA: " + quantityElementName+" LINE DATA: " + linesArray[i]);
        //         lineData = ExtractSingleLineFromDict(linesArray[i], quantityElementName);
        //         //MSG("Processing line " + i + ": " + lineData);
        //         if (lineData != null) {
        //             lineItems.Add(lineData);
        //         }
        //     }
        // } else {
        //     // Single line
        // //MSG("Processing single line: " + lineData);    
        //     lineData = ExtractSingleLineFromDict(linesArray, quantityElementName);
        //     if (lineData != null) {
        //         lineItems.Add(lineData);
        //     }
        // }
        
      //msg ("FINAL LINE ITEMS: " + lineItems);   

        // MSG("LINE ITEMS:\n" + lineItems);

        // x123123 =  lineItems;
        // msg("x123123:\n" + x123123);

        // MSG("LINE ITEMS:\n" + lineItems);


        // return lineItems;
        return;
        
    } catch (error) {
        MessageBox("Greška prilikom izvlačenja stavki: " + error);
        return null;
    }
}

// Extract single line item data from Dictionary
function ExtractSingleLineFromDict(lineDict, quantityElementName) {
    try {
        lineData = {};
        
        // LINE DICT JE JEDNA LINIJA

        // MSG(lineDict);

        // MSG("ID:\n\n" + lineDict["ID"]);


        // Basic line information
        // lineData["NKPR_LN_BR_LN"] = GetDictValue(lineDict, "ID");

        lineData["NKPR_LN_BR_LN"] = lineDict["ID"];

    // msg ("LINE ID: " + lineData["NKPR_LN_BR_LN"]);

        // Quantity and unit
        // quantity = GetDictValue(lineDict, quantityElementName);
        quantity = lineDict[quantityElementName]["@text"];
        if (quantity != "") {
            lineData["NKPR_LN_PQTY"] = ParseDecimal(quantity);
            
            // Unit code (might be in attributes - handle as needed)
            // unitCode = GetDictValue(lineDict, quantityElementName + ".unitCode");
            unitCode = lineDict[quantityElementName]["@attributes"]["unitCode"];
            // MSG("UNIT CODE RAW: " + unitCode);
            lineData["NKPR_LN_JEDMJ"] = GetUnitCodeFromUN(unitCode);
        }
        
        // Line amount
        //lineData["NKPR_LN_AMT"] = ParseDecimal(GetDictValue(lineDict, "LineExtensionAmount"));
        // lineData["NKPR_LN_AMT"] = ParseDecimal(GetDictValue(lineDict, "LineExtensionAmount"));
        lineData["NKPR_LN_AMT"] = ParseDecimal(lineDict["LineExtensionAmount"]["@text"]);
        // MSG("LINE AMT RAW: " + lineData["NKPR_LN_AMT"]);

    //msg ("LINE AMT: " + lineData["NKPR_LN_AMT"]);    
        // Item information
        // item = GetDictValue(lineDict, "Item");
        item = lineDict["Item"];
        // MSG("ITEM RAW: " + item);

        if (item != null && item != "") {

            lineData["NKPR_LN_PDESC"] = item["Name"];
            // msg("LINE DESC: " + lineData["NKPR_LN_PDESC"]);

            // Product code - try different locations
            // productCode = GetDictValue(item, "BuyersItemIdentification.ID");
            if(Contains(item, "BuyersItemIdentification")){
                //MSG("25561: NEEDS TESTING !!!");
                bii = item["BuyersItemIdentification"];
                biiId = bii["ID"];    
                lineData["NKPR_LN_PCODE"] = biiId;       
            }           

            if(Contains(item, "StandardItemIdentification")){
                //MSG("25562: NEEDS TESTING !!!");
                sii = item["StandardItemIdentification"];
                siiId = sii["ID"];    
                lineData["NKPR_LN_BARCODE"] = siiId; 
                if (siiId == "") {
                    lineData["NKPR_LN_PCODE"] = siiId;       
                }     
            }             

            // if (productCode == "") {
            //     productCode = GetDictValue(item, "SellersItemIdentification.ID");
            // }
            // lineData["NKPR_LN_PCODE"] = productCode;


            // msg ("LINE Product: " + lineData["NKPR_LN_PCODE"]+ " DESC: " + lineData["NKPR_LN_PDESC"]);    
            
            // Tax information - Convert XML tax category to internal PKFK_TAX_CODE
            // Reverse process from wxeracun.cscs
            // taxCategory = GetDictValue(item, "ClassifiedTaxCategory");
            taxCategory = item["ClassifiedTaxCategory"];
            // MSG("TAX CATEGORY RAW: " + taxCategory);
            
            xmlTaxCategoryID = "";
            xmlTaxPercent = 0;
            
            if(Contains(taxCategory, "Percent")){
                xmlTaxPercent = ParseDecimal(taxCategory["Percent"]);
                lineData["NKPR_LN_PRNPR"] = xmlTaxPercent;
            }else{
                Msg("Stopa poreza nije unesena u liniji " + lineData["NKPR_LN_BR_LN"] + ", račun nije validan!")    
            }

            if(Contains(taxCategory, "ID")){
                xmlTaxCategoryID = taxCategory["ID"];
            }else{
                Msg("Kategorija poreza nije unesena u liniji " + lineData["NKPR_LN_BR_LN"] + ", račun nije validan!")    
            }

      //msg ("TAX Category ID: " + xmlTaxCategoryID + " Percent: " + xmlTaxPercent);      
            // Look up internal tax code from PKFKPORZ table
            // Match by PKFK_TAX_TARIFA (category) and PKFK_TAX_STOPA (percent)
            internalTaxCode = LookupTaxCode(xmlTaxCategoryID, xmlTaxPercent);
            if (internalTaxCode > 0) {
                lineData["NKPR_LN_TXBLE"] = internalTaxCode;
                msg("Tax code converted: Category=" + xmlTaxCategoryID + ", Percent=" + xmlTaxPercent + " -> Internal Code=" + internalTaxCode);
            } else {
                msg("WARNING: No matching tax code found in PKFKPORZ for Category=" + xmlTaxCategoryID + ", Percent=" + xmlTaxPercent);
                lineData["NKPR_LN_TXBLE"] = 0;
            }
        }

        // Price information
        // price = GetDictValue(lineDict, "Price");
        price = lineDict["Price"];
        // Msg("PRICE RAW: " + price);

        // if (price != null && price != "") {
        lineData["NKPR_LN_PPRCE"] = ParseDecimal(price["PriceAmount"]["@text"]);
        // msg("LINE PRICE: " + lineData["NKPR_LN_PPRCE"]);
        // }
        
        // Allowances and charges
        // allowanceCharge = GetDictValue(lineDict, "AllowanceCharge");


        if(Contains(price, "AllowanceCharge")){
            allowanceCharge = price["AllowanceCharge"];

            discountAmount = (lineData["NKPR_LN_PQTY"] * lineData["NKPR_LN_PPRCE"]) - lineData["NKPR_LN_AMT"];
            postotak = (discountAmount / (lineData["NKPR_LN_PQTY"] * lineData["NKPR_LN_PPRCE"])) * 100;

            MSG("discountAmount: " + discountAmount);
            MSG("postotak: " + postotak);

            // if (allowanceCharge != null && allowanceCharge != "") {
            //     // Handle both single and multiple allowance/charge entries
            //     if (ArrayOrDict(allowanceCharge) == "array") {
            //         for (i = 0; i < Size(allowanceCharge); i++) {
            //             ProcessAllowanceCharge(allowanceCharge[i]);
            //         }
            //     } else {
            //         ProcessAllowanceCharge(allowanceCharge);
            //     }
            // }
        }


        //msg ("LINE PRICE: " + lineData["NKPR_LN_PPRCE"]);   
        // Notes
        // lineNote = GetDictValue(lineDict, "Note");
        // lineNote = GetDictValue(lineDict, "Note");
        // if (lineNote != "") {
        //     //lineData["NKPR_LN_NOTE"] = lineNote;
        // }
        
        // // Extract line item attachment if present
        // lineAttachmentNum = ExtractLineItemAttachments(lineDict, lineData["NKPR_LN_BR_LN"]);
        // if (lineAttachmentNum > 0) {
        //     lineData["NKPR_LN_SASTAV"] = lineAttachmentNum;
        // } else {
        //     if(!Contains(lineData, "NKPR_LN_SASTAV")) {
        //         lineData["NKPR_LN_SASTAV"] = 0;
        //     }
        // }
        
        //msg ("FINAL LINE DATA: " + lineData);    
        return lineData;
        
    } catch (error) {
        MessageBox("Greška prilikom izvlačenja stavke: " + error);
        return null;
    }
}

// Process allowance/charge for line item
function ProcessAllowanceCharge(allowanceChargeDict, lineData) {
    chargeIndicator = allowanceChargeDict["ChargeIndicator"];
    // amount = ParseDecimal(allowanceChargeDict["Amount"]["@text"]);
    
    if (chargeIndicator == "false" && amount > 0) {
        // This is an allowance (discount)
        lineData["NKPR_LN_POPL"] = amount;
        
        // Calculate discount percentage
        grossAmount = lineData["NKPR_LN_PQTY"] * lineData["NKPR_LN_PPRCE"];
        if (grossAmount > 0) {
            lineData["NKPR_LN_PDISC"] = (amount / grossAmount) * 100;
        }
    } elif (chargeIndicator == "true" && amount > 0) {
        // This is a charge - handle as negative discount
        lineData["NKPR_LN_POPL"] = -amount;
        
        grossAmount = lineData["NKPR_LN_PQTY"] * lineData["NKPR_LN_PPRCE"];
        if (grossAmount > 0) {
            lineData["NKPR_LN_PDISC"] = -(amount / grossAmount) * 100;
        }
    }
}


function end(){
    cursor("dflt");
    //MessageBox("Kraj");
    exit;
}

// Helper function to check if value is an array
function IsArray(value) {
    return (value != null && value.type() == "object" && value.Length != undefined);
}

// Helper function to check if value is a string
function IsString(value) {
//msg ("HHHH Value: " + value+" TYPE: " + value.type());    
    return (value.type() == "STRING");
}

// Helper function to check if value is a primitive (leaf) value (not a dictionary/object)
// Primitive types include: STRING, INTEGER, DOUBLE, BOOLEAN, etc.
// Non-primitive types: OBJECT (dictionaries), ARRAY
function IsPrimitiveValue(value) {
    if (value == null || value == "") {
        return true; // Treat null/empty as primitive
    }
    
    valueType = value.type();
    
    // Check if it's NOT a complex type (object/dictionary or array)
    // Primitive types: STRING, INTEGER, DOUBLE, BOOLEAN, etc.
    if (valueType == "OBJECT" || valueType == "ARRAY") {
        return false; // Complex type
    }
    
    return true; // It's a primitive type (string, number, boolean, etc.)
}

// Helper function to parse decimal values (enhanced)
function ParseDecimal(value) {
    if (value == "" || value == null) {
        return 0.00;
    }
    
    // If it's already a primitive value (number or string), convert directly
    if (IsPrimitiveValue(value)) {
        // Check if it's already numeric
        valueType = value.type();
        if (valueType == "DOUBLE" || valueType == "INTEGER") {
            return Double(value); // Already a number, just ensure it's double
        }
        // It's a string or other primitive, convert to double
        return Double(value);
    }
    
    // Handle dictionary/object values with #text element
    if (value.Contains("#text")) {
        return Double(value["#text"]);
    }
    
    // Fallback: try to convert to string then to double
    return Double(String(value));
}

// Helper function to safely get value from dictionary with dot notation support
function GetDictValue(dict, key) {
    if (dict == null || IsPrimitiveValue(dict)) {
        return dict; // Return the primitive value directly (string, number, boolean, etc.)
    }
    
    if (!Contains(key, ".")) {
        // Simple key
        if (Contains(dict, key)) {
            return dict[key];
        } else {
            return "";
        }
    } else {
        // Nested key with dot notation (e.g., "Item.Name")
        keys = Split(key, ".");
        currentDict = dict;
        
        for (i = 0; i < Size(keys); i++) {
            currentKey = keys[i];
            
            if (currentDict == null || IsPrimitiveValue(currentDict)) {
                return ""; // Hit a primitive value before reaching the end of the key path
            }
            
            if (Contains(currentDict, currentKey)) {
                currentDict = currentDict[currentKey];
            } else {
                return "";
            }
        }
        
        return currentDict;
    }
}
// Helper function to safely get value from dictionary with dot notation support
function GetDictValue2(dict, key) {
    if (dict == null || IsPrimitiveValue(dict)) {
        return dict; // Return the primitive value directly (string, number, boolean, etc.)
    }
msg("KKKK DICT: " + dict+" KEY: " + key);    
    if (!Contains(key, ".")) {
        // Simple key
        if (Contains(dict, key)) {
   msg("JJJJ VALUE: " + dict[key]);         
            return dict[key];
        } else {
            return "";
        }
    } else {
        // Nested key with dot notation (e.g., "Item.Name")
        keys = key.Split(".");
        currentDict = dict;
        
        for (i = 0; i < keys.size(); i++) {
            currentKey = keys[i];
            
            if (currentDict == null || IsPrimitiveValue(currentDict)) {
                return ""; // Hit a primitive value before reaching the end of the key path
            }
            
            if (Contains(currentDict, currentKey)) {
                currentDict = currentDict[currentKey];
            } else {
                return "";
            }
        }
        
        return currentDict;
    }
}

// Import header data into NKNAERGL table
function ImportHeaderDataToERGL(docType) {
    try {
        // Generate new record ID
        newRecordId = GetNextRecordId("NKNAERGL");
        NKPR_GL_BRPON = newRecordId;
        //invDate = now("yyyy-MM-dd").toString();
        //timeCreated = now("HH:mm:ss").toString();
        // Prepare SQL insert statement for NKNAERGL table
        sql_insert = "INSERT INTO " + databaseName + ".dbo.NKNAERGL (";
        sql_insert += "NKPR_GL_BRPON, NKPR_GL_OZNAKA, NKPR_GL_INVDTE, NKPR_GL_TIMECR, ";
        sql_insert += "NKPR_GL_DVO, NKPR_GL_NOKAM, NKPR_GL_ESD,  NKPR_GL_SIFDVZ, ";
        sql_insert += "NKPR_GL_JMBG, NKPR_GL_CUSNME, NKPR_GL_CUSA1, NKPR_GL_CUSCTY, ";
        sql_insert += "NKPR_GL_CUSZIP, NKPR_GL_CUSST,NKPR_GL_CUSCOD, ";
        sql_insert += "NKPR_GL_SHPCOD, NKPR_GL_SHPNME, NKPR_GL_SHPA1, NKPR_GL_SHPCTY, ";
        sql_insert += "NKPR_GL_SHPZIP, NKPR_GL_SHPST,";
        sql_insert += "NKPR_GL_SIF_PL, NKPR_GL_MODEL, NKPR_GL_POZIV, NKPR_GL_DATPRI, ";
        sql_insert += "NKPR_GL_TAXAMT, NKPR_GL_TOTAL, NKPR_GL_DESC,";
        sql_insert += "NKPR_GL_BROPIS1, NKPR_GL_REZ3, NKPR_GL_DATECR, NKPR_GL_DRZAVA, ";
        sql_insert += "NKPR_GL_POSRED, NKPR_GL_PICTHDR, NKPR_GL_PICTFTR";
        sql_insert += ") VALUES (";
        sql_insert += "@brpon, @docType, @invDate, @timeCreated, ";
        sql_insert += "@dvo, @nokam, @taxPointDate, @currency, ";
        sql_insert += "@custOIB, @custName, @custAddress, @custCity, ";
        sql_insert += "@custZip, @custState, @custCode, ";
        sql_insert += "@shpCode, @shpName, @shpAddress, @shpCity, ";
        sql_insert += "@shpZip, @shpState, ";
        sql_insert += "@payment, @model, @poziv, @datpri, ";
        sql_insert += "@taxTotal, @total, @glDesc, ";
        sql_insert += "@note, @rez3, @created, @country, @posred, ";
        sql_insert += "@pictHdr, @pictFtr ";
        sql_insert += ");";
        
        // Prepare parameters
        sqlParams = {};
        // sqlParams.Add({"@invNum", NKPR_GL_NUM});
        sqlParams.Add({"@brpon", newRecordId});
        sqlParams.Add({"@docType", NKPR_GL_OZNAKA});
        sqlParams.Add({"@invDate", NKPR_GL_INVDTE});
        sqlParams.Add({"@timeCreated", NKPR_GL_TIMECR});
        
        sqlParams.Add({"@dvo", NKPR_GL_DVO});
        sqlParams.Add({"@nokam", NKPR_GL_NOKAM});
        
        sqlParams.Add({"@taxPointDate", NKPR_GL_ESD});

        sqlParams.Add({"@currency", NKPR_GL_SIFDVZ});
        sqlParams.Add({"@custOIB", NKPR_GL_JMBG});

        if(NKPR_GL_CUSNME.length > 50){
            NKPR_GL_CUSNME = Substring(NKPR_GL_CUSNME, 0, 50);
        }
        sqlParams.Add({"@custName", NKPR_GL_CUSNME}); /////// 50 

        if(NKPR_GL_CUSA1.length > 50){
            NKPR_GL_CUSA1 = Substring(NKPR_GL_CUSA1, 0, 50);
        }
        sqlParams.Add({"@custAddress", NKPR_GL_CUSA1}); ///// 50
        
        if(NKPR_GL_CUSCTY.length > 40){
            NKPR_GL_CUSCTY = Substring(NKPR_GL_CUSCTY, 0, 40);
        }
        sqlParams.Add({"@custCity", NKPR_GL_CUSCTY}); ////// 40
        
        
        sqlParams.Add({"@custZip", NKPR_GL_CUSZIP});
        sqlParams.Add({"@custState", NKPR_GL_CUSST});
        sqlParams.Add({"@custCode", NKPR_GL_CUSCOD});
        
        if(NKPR_GL_SHPCOD.length > 10){
            NKPR_GL_SHPCOD = Substring(NKPR_GL_SHPCOD, 0, 10);
        }
        sqlParams.Add({"@shpCode", NKPR_GL_SHPCOD});
        
        if(NKPR_GL_SHPNME.length > 50){
            NKPR_GL_SHPNME = Substring(NKPR_GL_SHPNME, 0, 50);
        }
        sqlParams.Add({"@shpName", NKPR_GL_SHPNME});
        
        if(NKPR_GL_SHPA1.length > 50){
            NKPR_GL_SHPA1 = Substring(NKPR_GL_SHPA1, 0, 50);
        }
        sqlParams.Add({"@shpAddress", NKPR_GL_SHPA1});
        
        if(NKPR_GL_SHPCTY.length > 40){
            NKPR_GL_SHPCTY = Substring(NKPR_GL_SHPCTY, 0, 40);
        }
        sqlParams.Add({"@shpCity", NKPR_GL_SHPCTY});
        
        sqlParams.Add({"@shpZip", NKPR_GL_SHPZIP});
        sqlParams.Add({"@shpState", NKPR_GL_SHPST});
//sqlParams.Add({"@shpGLN", NKPR_AD_GLN"]});
        sqlParams.Add({"@payment", NKPR_GL_SIF_PL});
        sqlParams.Add({"@model", NKPR_GL_MODEL});
        sqlParams.Add({"@poziv", NKPR_GL_POZIV});
      
        sqlParams.Add({"@datpri", NKPR_GL_DATPRI});
        //sqlParams.Add({"@lineTotal", NKPR_GL_LINETOTAL});
        sqlParams.Add({"@taxTotal", NKPR_GL_TAXAMT});
        sqlParams.Add({"@total", NKPR_GL_TOTAL});
        //sqlParams.Add({"@payable", NKPR_GL_PAYABLE});
        
        sqlParams.Add({"@glDesc", NKPR_GL_DESC}); /////// 40
        
        // sqlParams.Add({"@note", NKPR_GL_BROPIS1});
        sqlParams.Add({"@note", 0});

        sqlParams.Add({"@rez3", NKPR_GL_REZ3});
        sqlParams.Add({"@created", NKPR_GL_INVDTE}); //????
        sqlParams.Add({"@country", NKPR_GL_DRZAVA});        
        sqlParams.Add({"@posred", NKPR_GL_POSRED}); // invoiceId
        
        sqlParams.Add({"@pictHdr", NKPR_GL_PICTHDR});
        sqlParams.Add({"@pictFtr", NKPR_GL_PICTFTR});

        // Execute SQL insert
        // msg("sqlParams  : " + sqlParams);
        result = SqlNonQuery(sql_insert, sqlParams);
        
        if (result > 0) {
            return newRecordId;
        } else {
            throw "SQL insert neuspješan";
        }
        
    } catch (error) {
        throw "Greška prilikom unosa zaglavlja: " + error;
    }
}

// Import line items into NKNAERLN table
// Import line items into NKNAERLN table
function ImportLineItemsToERLN(recordId, lineItems) {
  //msg("Importing line items for Record ID: " + recordId);      
    try {

        // msg("lineItems: " + lineItems);

        for (i = 0; i < Size(lineItems); i++) {
            lineData = lineItems[i];
            
            // msg(lineData);

            if(!Contains(lineData, "NKPR_LN_PCODE"))
            {
                lineData["NKPR_LN_PCODE"] = "";
            }
            if(!Contains(lineData, "NKPR_LN_TXBLE"))
            {
                lineData["NKPR_LN_TXBLE"] = 0;
            }
            if(!Contains(lineData, "NKPR_LN_POPL"))
            {
                lineData["NKPR_LN_POPL"] = 0;
            }
            if(!Contains(lineData, "NKPR_LN_PRNPR"))
            {
                lineData["NKPR_LN_PRNPR"] = 0;
            }
            if(!Contains(lineData, "NKPR_LN_PDISC"))
            {
                lineData["NKPR_LN_PDISC"] = 0;
            }
            if(!Contains(lineData, "NKPR_LN_BROPI"))
            {
                lineData["NKPR_LN_BROPI"] = 0;
            }
    
            sql_insert = "INSERT INTO " + databaseName + ".dbo.NKNAERLN (";
            sql_insert += "NKPR_LN_INVNM, NKPR_LN_BR_LN, NKPR_LN_PQTY, NKPR_LN_AMT, ";
            sql_insert += "NKPR_LN_PCODE, NKPR_LN_PDESC, NKPR_LN_JEDMJ, ";
            sql_insert += "NKPR_LN_PPRCE, NKPR_LN_PRNPR, NKPR_LN_TXBLE, ";
            sql_insert += "NKPR_LN_POPL, NKPR_LN_PDISC, NKPR_LN_BROPI, NKPR_LN_SASTAV";
            sql_insert += ") VALUES (";
            sql_insert += "@recordId, @lineNum, @qty, @amount, ";
            sql_insert += "@productCode, @description, @unit, ";
            sql_insert += "@price, @taxPercent, @taxable, ";
            sql_insert += "@discount, @discountPercent, @note, @attachmentId";
            sql_insert += ");";
            
            sqlParams = {};
            sqlParams.Add({"@recordId", NKPR_GL_BRPON});
            
            sqlParams.Add({"@lineNum", i + 1});
            sqlParams.Add({"@qty", lineData["NKPR_LN_PQTY"]});
            sqlParams.Add({"@amount", lineData["NKPR_LN_AMT"]});
            sqlParams.Add({"@productCode", lineData["NKPR_LN_PCODE"]});

            pDesc = lineData["NKPR_LN_PDESC"];
            if(pDesc.length > 50){
                pDesc = Substring(pDesc, 0, 50);
            }
            sqlParams.Add({"@description", pDesc}); ///// 50

            sqlParams.Add({"@unit", lineData["NKPR_LN_JEDMJ"]});
            sqlParams.Add({"@price", lineData["NKPR_LN_PPRCE"]});
            sqlParams.Add({"@taxPercent", lineData["NKPR_LN_PRNPR"]});
            sqlParams.Add({"@taxable", lineData["NKPR_LN_TXBLE"]});
            sqlParams.Add({"@discount", lineData["NKPR_LN_POPL"]});
            sqlParams.Add({"@discountPercent", lineData["NKPR_LN_PDISC"]});
            sqlParams.Add({"@note", lineData["NKPR_LN_BROPI"]});
            
            // Add line item attachment ID if present
            lineAttachmentId = 0;
            if (Contains(lineData, "NKPR_LN_SASTAV")) {
                lineAttachmentId = lineData["NKPR_LN_SASTAV"];
            }
            sqlParams.Add({"@attachmentId", lineAttachmentId});
                   
            result = SqlNonQuery(sql_insert, sqlParams);
            if (result == 0) {
                throw "Greška prilikom unosa stavke " + (i + 1);
            }
        }
        
        return true;
        
    } catch (error) {
        throw "Greška prilikom unosa stavki: " + error;
    }
}

// Log to NKSYELOG table
function LogToNKSYELOG(recordId, xmlFilePath, status) {
    try {
        sql_log = "INSERT INTO " + databaseName + ".dbo.NKSYELOG (";
        sql_log += "SY_ELOG_DATE, SY_ELOG_PERSON, SY_ELOG_PROGRAM, SY_ELOG_MESSAGE, ";
        sql_log += "SY_ELOG_RECORDID, SY_ELOG_STATUS";
        sql_log += ") VALUES (";
        sql_log += "@logDate, @logUser, @logProgram, @logMessage, @recordId, @status";
        sql_log += ");";
        
        sqlParams = {};
        sqlParams.Add({"@logDate", Now("yyyy-MM-dd")});
        sqlParams.Add({"@logUser", userCode});
        sqlParams.Add({"@logProgram", "WxEracunGet"});
        sqlParams.Add({"@logMessage", "XML Invoice Import: " + xmlFilePath});
        sqlParams.Add({"@recordId", recordId});
        sqlParams.Add({"@status", status});
        
        SqlNonQuery(sql_log, sqlParams);
        
    } catch (error) {
        // Don't throw error for logging issues
        MessageBox("Warning: Could not log to NKSYELOG: " + error);
    }
}

// Helper function to get next record ID
function GetNextRecordId(tableName) {
    sql_max = "SELECT isnull(MAX(NKPR_GL_BRPON),0) AS lastNum FROM " + databaseName + ".dbo." + tableName;
    result = sqlQuery(sql_max);
    if (Size(result) >= 2 && result[1][0] != 0) {
        return (result[1][0] + 1);
    } else {
        // First record
        return 1; // Starting ID
    }
}
 
// Helper function to convert UN unit codes back to internal codes
function GetUnitCodeFromUN(unCode) {
    if (unCode == "H87") { return "KOM"; }
    if (unCode == "KGM") { return "KG"; }
    if (unCode == "LTR") { return "LIT"; }
    if (unCode == "MTK") { return "MX2"; }
    if (unCode == "MTQ") { return "MX3"; }
    if (unCode == "TNE") { return "TON"; }
    if (unCode == "GRM") { return "GR"; }
    if (unCode == "HUR") { return "SAT"; }
    if (unCode == "DAY") { return "DAN"; }
    if (unCode == "MTR") { return "MET"; }
    if (unCode == "XCT") { return "KAR"; }
    if (unCode == "XPB") { return "PAL"; }
    if (unCode == "C62") { return "JED"; }
    return "KOM"; // Default
}

// // Helper function to parse invoice number from UBL format
// function ParseInvoiceNumber(ublInvNum) {
//     // Convert from format "00002-90-1" to "90100002"
//     if (Contains(ublInvNum, "-")) {
//         parts = Split(ublInvNum, "-");
//         if (Size(parts) == 3) {
//             return int(parts[1] + parts[2] + parts[0]);
//         }
//     }
//     return int(ublInvNum);
// }

// Validate if invoice ESD date belongs to current fiscal year
function ValidateFiscalYear() {
    return true; // Temporarily disable fiscal year check
    try {
        //if (esdDate == "" || esdDate == null) {
        //    return false; // No ESD date provided
        //}
        
        // Parse fiscal year from KPSY_FISCAL_YR (format: YYYY-MM-DD or similar)
        fiscalYear = year(KPSY_FISCAL_YR);
        
        // Parse year from ESD date (format: YYYY-MM-DD)
        esdYear =  year(gl_esd);
        // Compare years
        return (esdYear == fiscalYear);
        
    } catch (error) {
        MessageBox("Greška prilikom validacije fiskalne godine: " + error);
        return false;
    }
}


/* 
Usage Examples:

Database Tables Used:
- NKNAERGL: Header table for imported e-invoices
- NKNAERLN: Line items table for imported e-invoices  
- NKSYELOG: System log for import tracking

Fiscal Year Validation:
- Only invoices with ESD date matching KPSY_FISCAL_YR are imported
- Mismatched invoices are moved to archive without import
*/


function LogNKSYELOG(elogStatusCode, _invoiceId, description = ""){
    sqlQueryString = "INSERT INTO " + databaseName + ".dbo.NKSYELOG 
    (sy_elog_num, sy_elog_date, sy_elog_status, sy_elog_person, sy_elog_estring, sy_elog_type, sy_elog_time, sy_elog_desc, sy_elog_rez3, sy_elog_rez)
    VALUES (@p1, @p2, @p3, @p4, @p5, @p6, @p7, @p8, @p9, @p10);";

    sqlParams = {};
    sqlParams.Add({"@p1", NKPR_GL_BRPON});
    sqlParams.Add({"@p2", NKPR_GL_INVDTE});
    sqlParams.Add({"@p3", elogStatusCode.Upper()});
    sqlParams.Add({"@p4", userCode});
    sqlParams.Add({"@p5", "" });
    sqlParams.Add({"@p6", "UR"});
    sqlParams.Add({"@p7", Now("HH:mm:ss")});
    sqlParams.Add({"@p8", description});
    sqlParams.Add({"@p9", Now("yyyy-MM-dd")});
    sqlParams.Add({"@p10", _invoiceId});
    sqlQuery(sqlQueryString, sqlParams);
    return;
}

// -----------------------------------------------------------
// Extract attachments from UBL XML and save to disk
// Reverse process from wxeracun.cscs
// -----------------------------------------------------------
function ExtractAndSaveAttachments(invoiceDict, docType) {
    try {
        msg("=== ATTACHMENT EXTRACTION STARTING ===");

        // Get the root document data
        docData = invoiceDict;
        // if (docType == "S" && Contains(invoiceDict, "Invoice")) {
        //     docData = invoiceDict["Invoice"];
        // } elif (docType == "O" && Contains(invoiceDict, "CreditNote")) {
        //     docData = invoiceDict["CreditNote"];
        // } elif (docType == "T" && Contains(invoiceDict, "DebitNote")) {
        //     docData = invoiceDict["DebitNote"];
        // }
        
        
        // Initialize attachment counters
        NKPR_GL_PICTHDR = 0;  // Header attachment
        NKPR_GL_PICTFTR = 0;  // Footer attachment
        attachmentCounter = 0;
        


        // vanjski pdf attachment
        if(Exists(pdfPathInIMPORTED)){
            // Get next available NKSYPICT number
            sql_max_pic = "SELECT ISNULL(MAX(SY_SL_NUM), 0) AS maxNum FROM " + databaseName + ".dbo.NKSYPICT";
            maxRes = sqlQuery(sql_max_pic);
            
            nextPicNum = 1;
            if (Size(maxRes) >= 2) {
                nextPicNum = maxRes[1][0] + 1;
            }

            newPdfName = pdfPathInIMPORTED.Replace("p0.pdf", nextPicNum + ".pdf");
            Move(pdfPathInIMPORTED, newPdfName);

            // Insert into NKSYPICT table
            sql_insert_pic = "INSERT INTO " + databaseName + ".dbo.NKSYPICT 
                (SY_SL_NUM, SY_SL_PATH, SY_SL_OPIS, SY_SL_REZ5, SY_SL_CODE, SY_SL_TIP)
                VALUES (@p1, @p2, @p3, @p4, @p5, @p6);";
            
            sqlParams = {};
            sqlParams.Add({"@p1", nextPicNum});

            sqlParams.Add({"@p2", newPdfName});

            // if(description.length > 50){
            //     description = Substring(description, 0, 50);
            // }
            sqlParams.Add({"@p3", "Vizualizacija XML-a"}); // Description

            slikaIliDokument = "D"; // Document
            sqlParams.Add({"@p4", slikaIliDokument});

            sqlParams.Add({"@p5", ""}); //$$$ NKPR_GL_CUSCOD
            sqlParams.Add({"@p6", "UR"}); // ulazni račun
            
            sqlNonQuery(sql_insert_pic, sqlParams);

            NKPR_GL_PICTHDR = nextPicNum;

            msg("Registered VANJSKI pdf attachment in NKSYPICT with ID: " + nextPicNum);
        }


        // Process AdditionalDocumentReference elements (contains attachments)
        if (Contains(docData, "AdditionalDocumentReference")) {
            additionalDocs = docData["AdditionalDocumentReference"];
            
            // Handle both single attachment and multiple attachments
            // if (additionalDocs.type() == "ARRAY") {
            //     for (i = 0; i < Size(additionalDocs); i++) {
            //         ProcessSingleAttachment(additionalDocs[i], i);
            //     }
            // } else {
            //     ProcessSingleAttachment(additionalDocs, 0);
            // }

            if (ArrayOrDict(additionalDocs) == "array") {
                for (i = 1; i <= Size(additionalDocs); i++) {
                    ProcessSingleAttachment(additionalDocs[i], i);
                }
            } else {
                ProcessSingleAttachment(additionalDocs, 1);
            }
        }
        
        // // Extract and save main PDF attachment if present
        // if (Contains(docData, "Attachment")) {
        //     mainAttachment = docData["Attachment"];
        //     if (Contains(mainAttachment, "EmbeddedDocumentBinaryObject")) {
        //         ProcessMainPdfAttachment(mainAttachment);
        //     }
        // }
        
        msg("=== ATTACHMENT EXTRACTION COMPLETE ===");
        msg("Header Attachment ID (NKPR_GL_PICTHDR): " + NKPR_GL_PICTHDR);
        msg("Footer Attachment ID (NKPR_GL_PICTFTR): " + NKPR_GL_PICTFTR);
        
        return true;
        
    } catch (error) {
        MessageBox("Greška pri extraction attachments: " + error);
        return false;
    }
}

// -----------------------------------------------------------
// Process single attachment from AdditionalDocumentReference
// -----------------------------------------------------------
function ProcessSingleAttachment(attachmentRef, attachmentIndex) {
    try {
        // Get attachment ID
        attachmentID = "";
        if (Contains(attachmentRef, "ID")) {
            attachmentID = attachmentRef["ID"];
        }
        
        // Get attachment description
        attachmentDesc = "";
        if (Contains(attachmentRef, "DocumentDescription")) {
            attachmentDesc = attachmentRef["DocumentDescription"];
        }
        
        // Extract embedded binary object
        if (Contains(attachmentRef, "Attachment")) {
            attachment = attachmentRef["Attachment"];
            if (Contains(attachment, "EmbeddedDocumentBinaryObject")) {
                embeddedObj = attachment["EmbeddedDocumentBinaryObject"];
                
                // Get MIME type and filename
                mimeCode = "";
                filename = "";
                base64Content = "";
                
                if (Contains(embeddedObj, "@attributes")) {
                    attrs = embeddedObj["@attributes"];
                    if(Contains(attrs, "mimeCode")) {
                        mimeCode = attrs["mimeCode"];
                    }
                    if(Contains(attrs, "filename")) {
                        filename = attrs["filename"];
                    }
                }
                
                // Get base64 content
                if (Contains(embeddedObj, "@text")) {
                    base64Content = embeddedObj["@text"];
                } else {
                    base64Content = embeddedObj;
                }
                
                if (base64Content != "" && filename != "") {
                    // Save attachment to disk and get reference number
                    attachmentNum = SaveAttachmentToDisk(base64Content, filename, attachmentDesc, attachmentID);
                    
                    if (attachmentNum > 0) {
                        // Determine attachment type (Header, Footer, or Line item)
                        // if (attachmentIndex == 0 && NKPR_GL_PICTHDR == 0) {
                        //     NKPR_GL_PICTHDR = attachmentNum;
                        //     msg("Saved Header attachment with num: " + attachmentNum);
                        // } el
                        if (attachmentIndex == 1 && NKPR_GL_PICTFTR == 0) {
                            NKPR_GL_PICTFTR = attachmentNum;
                            msg("Saved Footer attachment with num: " + attachmentNum);
                        } else {
                            // Line item attachment - would need to store in NKNAERLN reference
                            // Store in temporary array for later processing with line items
                            msg("Saved Line attachment with num: " + attachmentNum);
                        }
                    }
                }
            }
        }
        
    } catch (error) {
        msg("Greška pri obradi attachment: " + error);
    }
}

// // -----------------------------------------------------------
// // Process main PDF attachment (AdditionalDocumentReference with ID=X7)
// // -----------------------------------------------------------
// function ProcessMainPdfAttachment(attachmentRef) {
//     try {
//         if (Contains(attachmentRef, "EmbeddedDocumentBinaryObject")) {
//             embeddedObj = attachmentRef["EmbeddedDocumentBinaryObject"];
            
//             // Get MIME type and filename
//             mimeCode = "";
//             filename = "";
//             base64Content = "";
            
//             if (Contains(embeddedObj, "@attributes")) {
//                 attrs = embeddedObj["@attributes"];
//                 if (Contains(attrs, "mimeCode")) {
//                     mimeCode = attrs["mimeCode"];
//                 }
//                 if (Contains(attrs, "filename")) {
//                     filename = attrs["filename"];
//                 }
//             }
            
//             // Get base64 content
//             if (Contains(embeddedObj, "@text")) {
//                 base64Content = embeddedObj["@text"];
//             } else {
//                 base64Content = embeddedObj;
//             }
            
//             if (base64Content != "" && filename != "") {
//                 // Save main PDF attachment
//                 attachmentNum = SaveAttachmentToDisk(base64Content, filename, "Main PDF Attachment", "X7");
//                 if (attachmentNum > 0) {
//                     msg("Saved Main PDF attachment: " + filename + " with ID: " + attachmentNum);
//                 }
//             }
//         }
        
//     } catch (error) {
//         msg("Greška pri obradi main PDF attachment: " + error);
//     }
// }

// -----------------------------------------------------------
// Save attachment to disk and register in NKSYPICT table
// Returns the NKSYPICT reference number (SY_SL_NUM)
// -----------------------------------------------------------
function SaveAttachmentToDisk(base64Content, filename, description, attachmentID) {
    try {
        // Validate inputs
        if (base64Content == "" || filename == "") {
            //msg("Preskakanje praznog attachment ili filename");
            return 0;
        }
        
        // Create attachment directory if needed
        attachmentDir = UR_IMPORTED_DirectoryPath;
        if (!Exists(attachmentDir)) {
            MkDir(attachmentDir);
        }
        
        // // Generate unique filename with timestamp
        fileExtension = ParseFile(filename, "pfExt");
        // fileNameOnly = ParseFile(filename, "pfName");
        // timestamp = Now("yyyyMMdd_HHmmss");
        // uniqueFilename = fileNameOnly + "_" + NKPR_GL_POSRED + "_" + timestamp + fileExtension;
        fullFilePath = attachmentDir + "p" + ( attachmentCounter + 1 ) + fileExtension;
        
        // msg("Saving attachment to: " + fullFilePath);
        
        // Convert Base64 to file
        if (!Base642File(base64Content, fullFilePath)) {
            msg("Greška pri spremanju attachment datoteke: " + fullFilePath);
            return 0;
        }
        
        // msg("Attachment saved successfully: " + fullFilePath);
        attachmentCounter++;
        

        // Get next available NKSYPICT number
        sql_max_pic = "SELECT ISNULL(MAX(SY_SL_NUM), 0) AS maxNum FROM " + databaseName + ".dbo.NKSYPICT";
        maxRes = sqlQuery(sql_max_pic);
        
        nextPicNum = 1;
        if (Size(maxRes) >= 2) {
            nextPicNum = maxRes[1][0] + 1;
        }
        
        newPdfName = fullFilePath.Replace(parsefile(fullFilePath, "pfName"), nextPicNum);
        Move(fullFilePath, newPdfName);


        // Insert into NKSYPICT table
        sql_insert_pic = "INSERT INTO " + databaseName + ".dbo.NKSYPICT 
            (SY_SL_NUM, SY_SL_PATH, SY_SL_OPIS, SY_SL_REZ5, SY_SL_CODE, SY_SL_TIP)
            VALUES (@p1, @p2, @p3, @p4, @p5, @p6);";
        
        sqlParams = {};
        sqlParams.Add({"@p1", nextPicNum});

        sqlParams.Add({"@p2", newPdfName});
        if(description.length > 50){
            description = Substring(description, 0, 50);
        }
        sqlParams.Add({"@p3", description});

        slikaIliDokument = "D"; // Document
        if(fileExtension.Lower() == ".png" || fileExtension.Lower() == ".jpg" || fileExtension.Lower() == ".jpeg"){
            slikaIliDokument = ""; // Slika (Image)
        }
        sqlParams.Add({"@p4", slikaIliDokument});

        sqlParams.Add({"@p5", NKPR_GL_CUSCOD}); //$$$
        sqlParams.Add({"@p6", "UR"}); // ulazni račun
        
        sqlNonQuery(sql_insert_pic, sqlParams);
        msg("Registered attachment in NKSYPICT with ID: " + nextPicNum);
        
        return nextPicNum;
        
    } catch (error) {
        MessageBox("Greška pri spremanju attachmenta: " + error);
        return 0;
    }
}

// -----------------------------------------------------------
// Extract and save line item attachments
// Stores attachment ID in NKNAERLN.NKPR_LN_SASTAV field
// -----------------------------------------------------------
function ExtractLineItemAttachments(lineDict, lineNumber) {
    try {
        lineAttachmentID = 0;
        
        // Check if line has AttachmentReference or similar structure
        if (Contains(lineDict, "AdditionalDocumentReference")) {
            lineRef = lineDict["AdditionalDocumentReference"];
            
            // Handle both single and multiple references
            refsToProcess = {};
            if (lineRef.type() == "ARRAY") {
                refsToProcess = lineRef;
            } else {
                refsToProcess = {lineRef};
            }
            
            for (i = 0; i < Size(refsToProcess); i++) {
                ref = refsToProcess[i];
                
                // Get attachment ID
                attachmentID = "";
                if (Contains(ref, "ID")) {
                    attachmentID = ref["ID"];
                }
                
                // Get description
                attachmentDesc = "Line " + lineNumber + " attachment";
                if (Contains(ref, "DocumentDescription")) {
                    attachmentDesc = "Line " + lineNumber + ": " + ref["DocumentDescription"];
                }
                
                // Extract embedded binary object
                if (Contains(ref, "Attachment")) {
                    attachment = ref["Attachment"];
                    if (Contains(attachment, "EmbeddedDocumentBinaryObject")) {
                        embeddedObj = attachment["EmbeddedDocumentBinaryObject"];
                        
                        // Get MIME type and filename
                        mimeCode = "";
                        filename = "";
                        base64Content = "";
                        
                        if (Contains(embeddedObj, "@attributes")) {
                            attrs = embeddedObj["@attributes"];
                            if (Contains(attrs, "mimeCode")) {
                                mimeCode = attrs["mimeCode"];
                            }
                            if (Contains(attrs, "filename")) {
                                filename = attrs["filename"];
                            }
                        }
                        
                        // Get base64 content
                        if (Contains(embeddedObj, "@text")) {
                            base64Content = embeddedObj["@text"];
                        } else {
                            base64Content = embeddedObj;
                        }
                        
                        if (base64Content != "" && filename != "") {
                            // Save attachment to disk
                            lineAttachmentID = SaveAttachmentToDisk(base64Content, filename, attachmentDesc, attachmentID);
                            if (lineAttachmentID > 0) {
                                msg("Saved Line " + lineNumber + " attachment: " + filename + " with ID: " + lineAttachmentID);
                                // Return first attachment ID found for this line
                                return lineAttachmentID;
                            }
                        }
                    }
                }
            }
        }
        
        return lineAttachmentID;
        
    } catch (error) {
        msg("Greška pri extraction line item attachments: " + error);
        return 0;
    }
}

// -----------------------------------------------------------
// Look up internal tax code (PKFK_TAX_CODE) from PKFKPORZ table
// Based on XML tax category ID and tax percent
// Reverse process from wxeracun.cscs
// -----------------------------------------------------------
function LookupTaxCode(xmlTaxCategoryID, xmlTaxPercent) {
    try {
        if (xmlTaxCategoryID == "" || xmlTaxCategoryID == null) {
            msg("WARNING: xmlTaxCategoryID is empty");
            return 0;
        }
        
        // Convert XML tax category to PKFK_TAX_TARIFA format
        // XML categories: S (standard), E (exempt), K (special), O (zero-rated), AE (reverse charge), etc.
        // Internal PKFK_TAX_TARIFA: PDV25, PDV13, PDV5, E, K, O, AE, etc.
        
        pkfkTaxTarifa = xmlTaxCategoryID;
        
        // If category is 'S' (standard VAT), need to convert to PDV format with rate
        if (xmlTaxCategoryID == "S") {
            // Standard VAT - combine with percent to create PKFK_TAX_TARIFA like "PDV25", "PDV13", "PDV5"
            pkfkTaxTarifa = "PDV" + String(int(xmlTaxPercent));
        }
        
        // Query PKFKPORZ table to find matching tax code
        // For compound tax codes (PKFK_TAX_TIP = 'S'), need to find individual codes
        // For simple tax codes (PKFK_TAX_TIP = '' or NULL), match directly
        
        sql_tax_lookup = "SELECT PKFK_TAX_CODE FROM " + databaseName + ".dbo.PKFKPORZ " +
                        "WHERE (PKFK_TAX_TIP = '' OR PKFK_TAX_TIP IS NULL) " +
                        "AND PKFK_TAX_P_PORZ IN ('R', 'T', 'O')" +
                        "AND (PKFK_TAX_TARIFA = @p1 OR PKFK_TAX_TARIFA LIKE @p1 + '%') " +
                        "AND PKFK_TAX_STOPA = @p2;";
        
        sqlParams = {};
        sqlParams.Add({"@p1", pkfkTaxTarifa});
        sqlParams.Add({"@p2", xmlTaxPercent});
        
        taxResult = sqlQuery(sql_tax_lookup, sqlParams);
        
        if (Size(taxResult) >= 2) {
            taxCode = taxResult[1][0];
            msg("Found tax code: " + taxCode + " for Category=" + xmlTaxCategoryID + " (" + pkfkTaxTarifa + "), Percent=" + xmlTaxPercent);
            return taxCode;
        }
        
        // If no exact match found, try to find by category only (for special cases)
        if (xmlTaxCategoryID != "S") {
            sql_tax_lookup2 = "SELECT TOP 1 PKFK_TAX_CODE FROM " + databaseName + ".dbo.PKFKPORZ " +
                            "WHERE (PKFK_TAX_TIP = '' OR PKFK_TAX_TIP IS NULL) " +
                            "AND PKFK_TAX_TARIFA = @p1;";
            
            sqlParams2 = {};
            sqlParams2.Add({"@p1", xmlTaxCategoryID});
            
            taxResult2 = sqlQuery(sql_tax_lookup2, sqlParams2);
            
            if (Size(taxResult2) >= 2) {
                taxCode = taxResult2[1][0];
                msg("Found tax code by category only: " + taxCode + " for Category=" + xmlTaxCategoryID);
                return taxCode;
            }
        }
        
        msg("WARNING: No tax code found for Category=" + xmlTaxCategoryID + " (" + pkfkTaxTarifa + "), Percent=" + xmlTaxPercent);
        return 0;
        
    } catch (error) {
        msg("Greška pri traženju tax code: " + error);
        return 0;
    }
}


function UnescapeFromXml(inputString){
    // return inputString.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;").Replace("\"", "&quot;").Replace("'", "&apos;");
    return inputString.Replace("&amp;", "&").Replace("&lt;", "<").Replace("&gt;", ">");
}