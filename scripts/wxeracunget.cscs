// -----------------------------------------------------------
// WxEracunGet.cscs - UBL XML Invoice Import Program
// -----------------------------------------------------------
// Purpose: Import UBL XML invoices into database tables
// Main Function: importUBLXml(xmlFilePath)
// Created: November 19, 2025
// Compatible with: wxeracun.cscs export format
// -----------------------------------------------------------
// Global variables for database connection
//databaseName = "your_database_name"; // Update with actual database name

Import(strTrim(mpath()) + "CSCS.Math.dll");

CreateWindow(strTrim(tpath()) + "wxeracunget.xaml");

DEFINE Rbr type i;
DEFINE cntr1 type i;

DEFINE arrayRbr type i size 100 array 10000;
DEFINE arrayDobavljac type a size 500 array 10000;
DEFINE arrayOibDobavljaca type a size 11 array 10000;
DEFINE arrayDatumIzdavanja type a size 10 array 10000;
DEFINE arrayDatumPDVa type a size 10 array 10000;
DEFINE arrayBrojRacuna type a size 50 array 10000;

DEFINE arrayBrojRacunaFina type a size 50 array 10000;
DEFINE arrayBrojRacunaMer type a size 50 array 10000;

// savedXmlFilesList = {};

function wxeracunget_onDisplay(){
    cursor("wait");
    SetWidgetOptions("btnPreuzmi", "IsEnabled", "false");
    SetWidgetOptions("StatusLabel", "Content", "Dohvaćanje liste ulaznih e-računa");
    SetWidgetOptions("StatusLabel2", "Content", "Pričekajte...");

    try{
        init();
        SetWindowOptions("wxeracungetWindow", "title", "Preuzimanje ulaznih e-računa(" + PROVIDER + ")");
        getList();
        DisplayArraySetup("datagridListaRacuna", counterFld: cntr1, activeElements: Rbr, maxElements: Rbr);
    }catch(ex){
        MessageBox("Greška pri inicijalizaciji:\n" + ex);
        // ??? LOG? ne?
        exit;
    }
    
    cursor("dflt");
    SetWidgetOptions("btnPreuzmi", "IsEnabled", "true");
    SetWidgetOptions("StatusLabel", "Content", "");
    SetWidgetOptions("StatusLabel2", "Content", "");
}

function init(){
    args = CommandLineArgs(); 
    if(Size(args) > 2){
        companyCode = args[2]; // e.g. Y3
        CoSet(companyCode);

        if(Size(args) > 3){
            userCode = args[3]; // e.g. ANA

        }else{
            MessageBox("Nedostaje user code u argumentima.");
            exit;
        }
    }else{
        companyCode = Substring(CoGet(), 1, 2);
    }


    // NKSYCCYR
    sqlQueryString = "select SY_CC_USER, SY_CC_DBASE from " + strtrim(CommonDBGet()) + ".dbo.NKSYCCYR WHERE SY_CC_CODE = '" + companyCode + "'";
    try
    {
        sqlResult = sqlQuery(sqlQueryString);
    }
    catch(ex)
    {
        MessageBox("Greška čitanja NKSYCCYR:\n" + ex);
        // ??? LOG? ne?
        exit;
    }

    if (size(sqlResult) > 1)
    {
        // imeFirme = sqlResult[1][0].trim(); // KAMEND
        // ovagod_h = sqlResult[1][1].trim(); // 2022
        SY_CC_USER = sqlResult[1][0].trim(); // KAMEND
        databaseName = sqlResult[1][1].trim(); // ime baze
    }    


    // NKSYSYCO Configuration
    sqlQueryString = " SELECT NKSYS_FIELD, NKSYS_VALUE 
        FROM " + databaseName + ".dbo.NKSYSYCO 
        WHERE NKSYS_MODUL = 'WKSY'
        AND NKSYS_GRUP = 'ERACUN'";
    try
    {
        sqlResult = sqlQuery(sqlQueryString);
    }
    catch(ex)
    {
        MessageBox("Greška čitanja NKSYSYCO:\n" + ex);
        // ??? LOG? ne?
        exit;
    }

    if (size(sqlResult) > 1)
    {
        for(i = 1; i < Size(sqlResult); i++){
            if(sqlResult[i][0].trim() == "FILESPATH"){
                FILESPATH = sqlResult[i][1].trim();
            }
            elif(sqlResult[i][0].trim() == "PROVIDER")
            {
                PROVIDER = sqlResult[i][1].trim();
            }
            elif(sqlResult[i][0].trim() == "SCHEMASPATH")
            {
                SCHEMASPATH = sqlResult[i][1].trim();
            }
        }
    }

    logFolder = FILESPATH + "UR\\" + "log\\";
    if (!Exists(logFolder)) {
        MkDir(logFolder);
    }


    // KPSYMSTR
    sqlQueryString = " SELECT TOP 1 KPSY_REZERVA, KPSY_COMP_NAME, KPSY_COMP_ADD1, KPSY_GL_RETEARN, KPSY_COMP_CSZ, KPSY_COMP_ZIP,
                    KPSY_COMP_JMBFI, KPSY_COMP_PHONE, KPSY_COMP_EMAIL, KPSY_PO_FREIGHT, KPSY_REZERVAX,KPSY_FISCAL_YR
                        FROM " + databaseName + ".dbo.KPSYMSTR";
    try
    {
        sqlResult = sqlQuery(sqlQueryString);
    }
    catch(ex)
    {
        MessageBox("Greška čitanja KPSYMSTR:\n" + ex);
        // !!! LOG ???
        exit;
    }

    if (size(sqlResult) > 1)
    {
        // proslaGodina = (int(ovagod_h) - 1);
        // nazivFirme = sqlResult[1][0].trim();
        // kpsy_po_freight= sqlResult[1][1].trim();
        // fiscal_yr = sqlResult[1][2];
        // local = sqlResult[1][3];

        KPSY_REZERVA = sqlResult[1][0].trim();
        KPSY_COMP_NAME = sqlResult[1][1].trim();
        KPSY_COMP_ADD1 = sqlResult[1][2].trim();
        KPSY_GL_RETEARN = sqlResult[1][3].trim();
        KPSY_COMP_CSZ = sqlResult[1][4].trim();
        KPSY_COMP_ZIP = sqlResult[1][5];
        KPSY_COMP_JMBFI = sqlResult[1][6].trim();
        KPSY_COMP_PHONE = sqlResult[1][7].trim();
        KPSY_COMP_EMAIL = sqlResult[1][8].trim();
        KPSY_PO_FREIGHT = substring(sqlResult[1][9], 0, 2).trim();
        KPSY_REZERVAX = sqlResult[1][10].trim(); // Supplier GLN
        KPSY_FISCAL_YR = sqlResult[1][11].trim();
    } 
}

function getList(){
    try {
        sql_erac = "SELECT
                ERAC_REZ1, ERAC_SERVER, ERAC_SERVERT, ERAC_USER, ERAC_PASS, ERAC_USERT, ERAC_PASST, ERAC_DESC 
                FROM " + databaseName + ".dbo.NKSYERAC WHERE ERAC_CODE = @p1;";
        sqlParams = {};
        // if(NKSC_POSREDNIK != ""){
        //     sqlParams.Add({"@p1", NKSC_POSREDNIK});
        //     PROVIDER = NKSC_POSREDNIK;
        // }else{
            sqlParams.Add({"@p1", PROVIDER});
        // }
        
        eracRes = sqlQuery(sql_erac, sqlParams);
        if (Size(eracRes) < 2) {
            MessageBox("Nema podataka o posredniku " + PROVIDER + "!");
            // !!! LOG !!!
            exit;
        }

        ERAC_REZ1 = eracRes[1][0].trim();
        ERAC_SERVER = eracRes[1][1].trim();
        ERAC_SERVERT = eracRes[1][2].trim();
        ERAC_USER = eracRes[1][3].trim();
        ERAC_PASS = eracRes[1][4].trim();
        ERAC_USERT = eracRes[1][5].trim(); // cer certificate
        ERAC_PASST = eracRes[1][6].trim(); // p12 certificate
        ERAC_DESC = eracRes[1][7].trim();
        
        companyOIB = substring(KPSY_REZERVA, 0, 11).trim();

        if (PROVIDER == "MER" || PROVIDER == "MERDEMO") {
            GetListMER();
        } elif (PROVIDER == "FINA" || PROVIDER == "FINADEMO") {
            GetListFINA();
        } else {
            MessageBox("Nepoznat provider: " + PROVIDER + ". Podržani su: MER, FINA");
            exit;
        }
    } catch (ex) {
        MessageBox("Greška u preuzimanju sa provider-a " + PROVIDER + ": " + ex);
        // !!! LOG !!!
        exit;
    }
}

function GetListFINA(){
    // GET INCOMING INVOICE LIST
    try{
        //MSG("Dohvaćam listu ULAZNIH računa preko FINA-e putem WSDL-a!");
        ack = FINA_GET_B2B_INCOMING_INVOICE_LIST(
            ERAC_SERVER + "B2BFinaInvoiceWebService/services/B2BFinaInvoiceWebService",
            ERAC_DESC, // "e-invoice" / NE "e-racun-winx" !
            ERAC_USERT, // servisni certifikat
            ERAC_PASST, // p12 certifikat (klijentski)
            ERAC_PASS, // password za p12 certifikat

            UUID(), // messageId
            "9934:" + companyOIB // OIB primatelja (VLASTITI) // !!! stavit pravi OIB iz baze
        );

        // MSG("ack = " + ack);
       
        // MSG("ackStatusText = " + ack["ackstatustext"]);

        if(ack["AckStatusCode"] == 10){
            if(!Contains(ack, "ErrorCode")){
                // MSG("U listi je " + Size(ack["InvoiceList"]) + " računa za preuzimanje sa FINA servera.");
                for(i = 0; i < Size(ack["InvoiceList"]); i++){
                    // MSG(ack["InvoiceList"][i]);

                    supplierName = ack["InvoiceList"][i]["SupplierRegistrationName"];
                    supplierId = ack["InvoiceList"][i]["SupplierId"];
                    // !!! datumi (2)
                    supplierInvoiceId = ack["InvoiceList"][i]["SupplierInvoiceID"];
                    invoiceId = ack["InvoiceList"][i]["InvoiceID"];

                    datumIzdavanja = ack["InvoiceList"][i]["InvoiceIssueDate"];
                    datumIzdavanja = Substring(datumIzdavanja, 0, 8);
                    datumPdva = ack["InvoiceList"][i]["InvoiceDate"];
                    datumPdva = Substring(datumPdva, 0, 8);

                    AddRacunToArrays(supplierName, supplierId, datumIzdavanja, datumPdva, supplierInvoiceId, invoiceId);
                }
            }else{
                MessageBox("ack[\"ErrorCode\"]" + ack["ErrorCode"] + "\nack[\"ErrorText\"]" + ack["ErrorText"] + "\nack[\"ErrorMessage\"]" + ack["ErrorMessage"]);
                exit;
            }
        }else{
            MessageBox("AckStatusText = " + ack["AckStatusText"]);
            // MessageBox("NEUSPJEŠNO poslan RAČUN prema FINA-i!");
            exit;
        }
    }catch(ex){
        MessageBox("Nepoznata greška:\n" + ex);
        LogException(ex); // !!!
        exit;
    }
}

function GetListMER(){
    // statusId = 40; // sent(and received)
    statusId = 30; // sent(not received)
    jsonPayload = '{"Username": "' + ERAC_USER + 
                    '", "Password": "' + ERAC_PASS + 
                    '", "CompanyId": "' + companyOIB + 
                    '", "SoftwareId": "' + ERAC_DESC + 
                    '", "StatusId": "' + statusId + 
                    '"}';
            
    try {
        apiUrl = ERAC_SERVER + "apis/v2/queryinbox";
        jsonResponse = WebRequest("POST", apiUrl, jsonPayload, "", "GetListMERSuccess", "GetListMERFailure", "application/json", null, 1000 * 20, false);
    } catch (ex) {
        MessageBox("Greška prilikom API poziva: " + ex);
        // !!! LOG !!!
        exit;
    }
}

function GetListMERSuccess(trackingId, responseCode, res) {
    MSG("MERSuccess"); // REMOVE

    try{
        LogResponse(responseCode, res);     

        res = res.ReplaceAndTrim("[", "", "]", "");
        resParts = res.Split("},{");

        for(i = 0; i < Size(resParts); i++){
            if(i == 0){
                resParts[i] = resParts[i] + "}";
            }
            elif(i == Size(resParts) - 1){
                resParts[i] = "{" + resParts[i];
            }else{
                resParts[i] = "{" + resParts[i] + "}";
            }

            racunObject = DeserializeJson(resParts[i]);
            
            AddRacunToArrays(
                racunObject["SenderBusinessName"],
                racunObject["SenderBusinessNumber"],
                "2025-01-01", // !!!
                "2025-01-01", // !!!
                racunObject["DocumentNr"],
                racunObject["ElectronicId"]
            );
        }
    }
    catch(ex){
        MessageBox("MERSuccess - Greška pri parsiranju odgovora poslužitelja:\n" + ex);
        // LogNKSYELOG(); // !!! LOG !!!
        exit;
    }
}

function GetListMERFailure(trackingId, responseCode, res) {
    MSG("MERFailure");

    try{
        LogResponse(responseCode, res);  
    }
    catch(ex){
        MessageBox("SendingFailure - Greška pri parsiranju odgovora poslužitelja:\n" + ex);
        // !!! LOG !!!
        exit;
    }
}


function AddRacunToArrays(supplierName, supplierId, datumIzdavanja, datumPdva, supplierInvoiceId, eRacunBrojRacuna){
    arrayDobavljac[Rbr] = supplierName;
    arrayOibDobavljaca[Rbr] = supplierId;
    arrayDatumIzdavanja[Rbr] = datumIzdavanja;
    arrayDatumPDVa[Rbr] = datumPdva;
    arrayBrojRacuna[Rbr] = supplierInvoiceId;
    

    if (PROVIDER == "MER" || PROVIDER == "MERDEMO") {
        arrayBrojRacunaMer[Rbr] = eRacunBrojRacuna;
    } elif (PROVIDER == "FINA" || PROVIDER == "FINADEMO") {
        arrayBrojRacunaFina[Rbr] = eRacunBrojRacuna;
    } else {
        MessageBox("Nepoznat provider: " + PROVIDER + ". Podržani su: MER, FINA, MERDEMO, FINADEMO");
        exit;
    }

    arrayRbr[Rbr] = ++Rbr;
}


//-----------------------------------------------------------

function btnPreuzmi@clicked(){
    cursor("wait");
    SetWidgetOptions("btnPreuzmi", "IsEnabled", "false");
    SetWidgetOptions("StatusLabel", "Content", "Preuzimanje...");

    AsyncCall("startDownload", "startImportCall");   
    // AsyncCall("startImport", "end");
}

function startDownload(){
    // Create incoming folder if it doesn't exist
    incomingFolder = FILESPATH + "UR\\";
    if (!Exists(incomingFolder)) {
        MkDir(incomingFolder);
    }

    if (PROVIDER == "MER" || PROVIDER == "MERDEMO") {
        GetRacuniMER();
    } elif (PROVIDER == "FINA" || PROVIDER == "FINADEMO") {
        GetRacuniFINA();
    } else {
        MessageBox("Nepoznat provider: " + PROVIDER + ". Podržani su: MER, FINA");
        exit;
    }
}

function GetRacuniFINA(){
    for(f = 0; f < Rbr; f++) {
        try{
            // MSG("Dohvaćam 1 ULAZNI račun preko FINA-e putem WSDL-a!");

            invoiceId = arrayBrojRacunaFina[f];
            xmlFilePath = FILESPATH + "UR\\" + "FINA_UR_" + invoiceId + ".xml";

            ack = FINA_GET_B2B_INCOMING_INVOICE(
                ERAC_SERVER + "B2BFinaInvoiceWebService/services/B2BFinaInvoiceWebService",
                ERAC_DESC, // "e-invoice" / NE "e-racun-winx" !
                ERAC_USERT, // servisni certifikat
                ERAC_PASST, // p12 certifikat (klijentski)
                ERAC_PASS, // password za p12 certifikat

                UUID(), // messageId
                "9934:" + companyOIB, // OIB primatelja (VLASTITI)
                invoiceId // invoiceId
            );

            // MSG("ack = " + ack);

            // MSG("ack[\"AckStatusCode\"] = " + ack["AckStatusCode"]);
            // MSG("ack[\"AckStatusText\"] = " + ack["AckStatusText"]);


            //Save XML
            SaveFile(ack["ItemContent"], xmlFilePath);
            // savedXmlFilesList.Add(xmlFilePath);

            // Save PDF
            Base642File(ack["Base64PdfDocumentString"], FILESPATH + "UR\\" + "FINA_UR_" + invoiceId + ".pdf");

            // NKSYELOG
            // !!! za FINA-u moramo postavit status računa na RECEIVING_CONFIRMED !!!
            // SET incoming invoice RECEIVING_CONFIRMED
            try{
                // MSG("Postavljam STATUS ulaznog računa " + invoiceId + " kod FINA-e putem WSDL-a!");

                ack = FINA_CHANGE_B2B_INCOMING_INVOICE_STATUS(
                    ERAC_SERVER + "B2BFinaInvoiceWebService/services/B2BFinaInvoiceWebService",
                    ERAC_DESC, // "e-invoice" / NE "e-racun-winx" !
                    ERAC_USERT, // servisni certifikat
                    ERAC_PASST, // p12 certifikat (klijentski)
                    ERAC_PASS, // password za p12 certifikat

                    UUID(), // messageId
                    "9934:" + companyOIB, // OIB primatelja (VLASTITI) // !!! stavit pravi OIB iz baze
                    invoiceId, // invoiceId
                    "RECEIVING_CONFIRMED"//, // newStatusCodeString
                    // "", // codeReasonString
                    // "" // note
                );

                // MSG("ack = " + ack);
            
                // MSG("ack[\"AckStatusCode\"] = " + ack["AckStatusCode"]);
                // MSG("ack[\"AckStatusText\"] = " + ack["AckStatusText"]);

            }catch(ex){
                MessageBox("Promjena statusa računa - Nepoznata greška:\n" + ex);
                LogException(ex);
            }
        }catch(ex){
            MessageBox("Račun " + invoiceId + "\nNepoznata greška:\n" + ex);
            LogException(ex); // !!! 
        }
    }
}

function GetRacuniMER(){
    for(h = 0; h < Rbr; h++) {
        try{
            // MSG("Dohvaćam 1 ULAZNI račun preko FINA-e putem WSDL-a!");

            invoiceId = arrayBrojRacunaMer[h];
            // trackingId = "MER_UR_" + racunObject["ElectronicId"] + "_" + racunObject["DocumentNr"] + "_" + racunObject["SenderBusinessNumber"]; // + "_" + racunObject["SenderBusinessName"];
            trackingId = "MER_UR_" + invoiceId;

            jsonPayload = '{"Username": "' + ERAC_USER + '", "Password": "' + ERAC_PASS + '", "CompanyId": "' + companyOIB + '", "SoftwareId": "' + ERAC_DESC + '", "ElectronicId": "' + invoiceId + '"}';

            WebRequest("POST", ERAC_SERVER + "apis/v2/receive", jsonPayload, trackingId, "MERReceiveRacunSuccess", "MERReceiveRacunFailure", "application/json", null, 1000 * 20, false);           
        }catch(ex){
            MessageBox("Račun " + invoiceId + "\nNepoznata greška:\n" + ex);
            LogException(ex); // !!! 
        }
    }    
}

function MERReceiveRacunSuccess(trackingId, responseCode, res) {
    MSG("MERReceiveRacunSuccess");
    // MSG("MERReceiveSuccess" + "\n" + XmlToDict(res));
    try{
        LogResponse(responseCode, res);

        xmlFilePath = FILESPATH + "UR\\" + trackingId + ".xml";
        SaveFile(res, xmlFilePath);
        // savedXmlFilesList.Add(xmlFilePath);
    }catch(ex){
        MessageBox("MERReceiveRacunSuccess - Greška pri parsiranju odgovora poslužitelja:\n" + ex);
        // !!! LOG !!!
    }
    
}

function MERReceiveRacunFailure(trackingId, responseCode, res) {
    MSG("MERReceiveRacunFailure");
    try{
        LogResponse(responseCode, res);  
    }
    catch(ex){
        MessageBox("MERReceiveRacunFailure - Greška pri parsiranju odgovora poslužitelja:\n" + ex);
        // !!! LOG !!!
    }
}


//-----------------------------------------------------------

function startImportCall(){
    AsyncCall("startImport", "end");
}

function startImport(){
    cd(FILESPATH + "UR\\");
    listOfXmls = FindFiles("*.xml");

    //MSG("LIST: " + listOfXmls);
    // MSG(Size(listOfXmls));

    ///for(xmlCounter = 0; xmlCounter < Size(listOfXmls); xmlCounter++){
    for(xmlCounter = 0; xmlCounter < 1; xmlCounter++){
        msg("IMPORTING: " + listOfXmls[xmlCounter]);
        xmlFilePath = listOfXmls[xmlCounter];
        MemoX = ""; //memo u kojega spremamo one podatke iz xml računa koje želimo prikazati korisniku prilikom uvoza

        xmlFilenameWithoutExtension = parsefile(xmlFilePath, "pfName");
        if(xmlFilenameWithoutExtension.StartsWith("FINA_UR_")){
            currentInvoiceId = xmlFilenameWithoutExtension.Replace("FINA_UR_", "");
        }elif(xmlFilenameWithoutExtension.StartsWith("MER_UR_")){
            currentInvoiceId = xmlFilenameWithoutExtension.Replace("MER_UR_", "");
        }else{
            currentInvoiceId = "";
        }

        importUBLXmlFromDict(ReadAllText(listOfXmls[xmlCounter]), currentInvoiceId);
    }
}

// New main import function using XmlToDict
//function importUBLXmlFromDict(xmlContent, xmlFilePath = "") {
function importUBLXmlFromDict(xmlContent, _invoiceId = "") {
    try {
        documentDict = XmlToDict(xmlContent);
        
        documentKeys = documentDict.Keys;
        documentType = documentKeys[0];

        invoiceDict = documentDict[documentType];


        NKPR_GL_POSRED = _invoiceId;
        
        // // //************
        // MSG(documentDict[documentType]["InvoiceLine"]); 


        // linesArray = documentDict[documentType]["InvoiceLine"];
        // MSG(linesArray);


        // MSG(documentDict[documentType]["InvoiceLine"]); 
        // // //************


        // MSG(documentDict["Invoice"]["InvoiceLine"]);

        if (invoiceDict == null || Size(invoiceDict) == 0) {
            MessageBox("Greška prilikom parsiranja XML-a u Dictionary");
            return false;
        }
        
        // Determine document type from dictionary structure
        docType = GetDocumentTypeFromDict(invoiceDict);
        if (docType == "") {
            MessageBox("Nepoznat tip dokumenta u XML datoteci");
            return false;
        }
        
        // Extract header information from dictionary
        if (!ExtractHeaderDataFromDict(invoiceDict, docType)) {
            MessageBox("Greška prilikom izvlačenja podataka zaglavlja");
            return false;
        }
        //   if (NKPR_GL_ESD"] == "") {NKPR_GL_ESD"] = NKPR_GL_INVDTE"];} 
        // Validate fiscal year before proceeding
        //if (!ValidateFiscalYear(NKPR_GL_ESD"])) {
        if (!ValidateFiscalYear(NKPR_GL_ESD)) {
            MessageBox("Račun se ne može importirati jer datum ESD (" + NKPR_GL_ESD + ") ne pripada fiskalnoj godini " + KPSY_FISCAL_YR + ". Račun će biti premješten u arhivu.");
            return "FISCAL_YEAR_MISMATCH";
        }
        //msg ("ESD: " + NKPR_GL_ESD + " FISCAL YR: " + KPSY_FISCAL_YR);
        // Extract line items from dictionary
        // lineItems = ExtractLineItemsFromDict(invoiceDict, docType);
        ExtractLineItemsFromDict(invoiceDict, docType);
        if (lineItems == null) {
            MessageBox("Greška prilikom izvlačenja stavki računa");
            return false;
        }
        //return;   
    
        // MSG("99999999" + lineItems);

        // Begin database transaction
        //BeginTransaction();
        
        try {
            // Import header data to NKNAERGL table
            //msg ("0000: xmlFilePath: " + xmlFilePath);   
            invNum = ImportHeaderDataToERGL(docType);
            msg ("1111: INVNUM: " + invNum);        
            if (invNum == 0) {
                throw "Greška prilikom unosa zaglavlja računa";
            }
            // Import line items to NKNAERLN table
            if (!ImportLineItemsToERLN(invNum, lineItems)) {
                throw "Greška prilikom unosa stavki računa";
            }
            // Log to NKSYELOG
            //msg("2222: xmlFilePath: " + xmlFilePath);    
            // LogToNKSYELOG(invNum, xmlFilePath, "IMPORT_SUCCESS");
            
            // Commit transaction
            //CommitTransaction();
            

            


            MessageBox("UBL XML račun je uspješno uvezen!\nBroj računa: " + invNum);


            // LogNKSYELOG("P", invNum, currentInvoiceId);

            return invNum;
            
        } catch (error) {
            // Rollback transaction on error
            //RollbackTransaction();
            //msg("4444: xmlFilePath: " + xmlFilePath + " ERROR: " + error);       
            // LogToNKSYELOG(0, xmlFilePath, "IMPORT_FAILURE: " + error);
            MessageBox("Greška prilikom unosa u bazu podataka: " + error);
            return false;
        }
        
    } catch (error) {
        MessageBox("Greška prilikom uvoza XML datoteke: " + error);
        return false;
    }
}

// Determine document type from Dictionary structure
function GetDocumentTypeFromDict(invoiceDict) {
    // Check which root element exists in dictionary
    if (Contains(invoiceDict, "Invoice")) { return "S"; }
    if (Contains(invoiceDict, "CreditNote")) { return "O"; }
    if (Contains(invoiceDict, "DebitNote")) { return "T"; }
    
    // Check if we have direct access to elements (flat structure)
    if (Contains(invoiceDict, "ID") && Contains(invoiceDict, "InvoiceTypeCode")) { return "S"; }
    if (Contains(invoiceDict, "ID") && Contains(invoiceDict, "CreditNoteTypeCode")) { return "O"; }
    if (Contains(invoiceDict, "ID") && Contains(invoiceDict, "DebitNoteTypeCode")) { return "T"; }
    
    return "";
}

// Extract header data from Dictionary
function ExtractHeaderDataFromDict(invoiceDict, docType) 
{
    try 
    {
        NKPR_GL_SHPA1 = "";
        NKPR_GL_SHPCOD = "";
        NKPR_GL_SHPCTY = "";
        NKPR_GL_SHPZIP = "";
        NKPR_GL_SHPST = "";
        NKPR_GL_SHPNME = "";
        NKPR_GL_SIF_PL = "";
        NKPR_GL_MODEL = "";
        NKPR_GL_POZIV = "";
        NKPR_GL_RZRVA1 = "";
        NKPR_GL_DESC = "";
        NKPR_GL_OZNAKA = "";
        NKPR_GL_DATPRI = "1900-01-01";
        NKPR_GL_TIMECR = now("HH:mm:ss").toString();
        NKPR_GL_DVO = "1900-01-01";
        NKPR_GL_INVDTE = now("yyyy-MM-dd").toString();
        NKPR_GL_NOKAM = 0;
        NKPR_GL_ROKPL = 0;
        NKPR_GL_ESD = "1900-01-01";
        NKPR_GL_SIFDVZ = "";
        NKPR_GL_CUSNME = "";
        NKPR_GL_CUSA1 = "";
        NKPR_GL_CUSCTY = "";
        NKPR_GL_CUSZIP = 0;
        NKPR_GL_DRZAVA = "";
        NKPR_GL_CUSST = "";
        NKPR_GL_JMBG = "";
        NKPR_GL_SUBTOT = 0;
        NKPR_GL_TOTAL = 0;
        NKPR_GL_TAXAMT = 0;
        NKPR_GL_REZ3 = 0;

        // Get the root document data (handle nested or flat structure)
        docData = invoiceDict;
        if (docType == "S" && Contains(invoiceDict, "Invoice")) {
            docData = invoiceDict["Invoice"];
        } elif (docType == "O" && Contains(invoiceDict, "CreditNote")) {
            docData = invoiceDict["CreditNote"];
        } elif (docType == "T" && Contains(invoiceDict, "DebitNote")) {
            docData = invoiceDict["DebitNote"];            }
            
        // Basic invoice information
        glDesc = docData["ID"]; //broj računa od dobavljača
        NKPR_GL_DESC = glDesc;
        if (docData["ID"].length > 50) {
            memoX = "Broj računa dobavljača je predug (" + docData["ID"].length + " znakova). Maksimalno dozvoljeno je 50 znakova.\nSkraćeni broj računa: " + Substring(docData["ID"], 0, 50);
        }
        //provjeriti kasnije kad imamo i OIB dobavljača, u NKNAERGL da li je taj broj već unesen/preuzet
        //sada još uzmimo copyIndictIndicator iz računa ako postoji
        copyIndicator = "";
        if (Contains(docData, "CopyIndicator")) {
            copyIndicator = docData["CopyIndicator"];
        }
        NKPR_GL_OZNAKA = docType;
        NKPR_GL_DATPRI = docData["IssueDate"];
        //issueDate = docData["IssueDate"].toString();
        //NKPR_GL_TIMECR"] = docData["IssueTime"];
        if (Contains(docData, "DueDate")){
            //tu staviti matematiku za datum dospijeća: duedate-issuedate=nokam kao broj dana, a dvo je isti kao i datum issuedate
            NKPR_GL_DVO = NKPR_GL_DATPRI;
            dueDate = docData["DueDate"];
            
            dueDateDateTime = DateTime(dueDate, "yyyy-MM-dd");
            datpriDateTime = DateTime(NKPR_GL_DATPRI, "yyyy-MM-dd");
            dateDiff = Math.Trunc(DateTimeToDouble(dueDateDateTime)) - Math.Trunc(DateTimeToDouble(datpriDateTime));

            NKPR_GL_NOKAM = dateDiff; // !!! hardcoded 30 days for now, TREBA POPRAVITI!!!
            // MSG("NKPR_GL_NOKAM: " + NKPR_GL_NOKAM);
       //msg("KKKK DueDate: " + NKPR_GL_DVO + " IssueDate: " + docData["IssueDate"]);         
        } else{
            NKPR_GL_DVO = docData["IssueDate"].toString();
            NKPR_GL_NOKAM = 0;
       //msg("LLLL DueDate: " + docData["DueDate"] + " IssueDate: " + docData["IssueDate"]);         
        }   
        //DueDate = docData["DueDate"].toString();
            
        // NKPR_GL_DUE_DATE"] = docData["DueDate"]; // !!!
        if (Contains(docData, "TaxPointDate")) {
            NKPR_GL_ESD = docData["TaxPointDate"];
            //GL_ESD = docData["TaxPointDate"].toString();
        }else{
            NKPR_GL_ESD = docData["IssueDate"];
            //GL_ESD = docData["IssueDate"].toString();
        }
        // Currency
        NKPR_GL_SIFDVZ = docData["DocumentCurrencyCode"];
        //sifdvz = docData["DocumentCurrencyCode"].toString();
        
        // Supplier information from AccountingSupplierParty
        suppParty = docData["AccountingSupplierParty"];
        if (suppParty != null && suppParty != "") {
            suppPartyData = suppParty;
            if (Contains(suppParty, "Party")) {
                suppPartyData = suppParty["Party"];
            }
            // Supplier OIB/GLN
            OIBSupp = "";
            GLNSupp = "";
            companyIDEndpointID = suppPartyData["EndpointID"]; // npr 12345678903
            companyIDPartyIdentificationID = suppPartyData["PartyIdentification"]["ID"]; // npr.: OIB 9934:12345678903 ili možda GLN 0088:12345678
            //refNumbers = Split(companyIDPartyIdentificationID, ":");
            refNumbers = companyIDPartyIdentificationID.split(":");
            //refIdx = 0;
            refNum = refNumbers[0].trim();
            refOIB = refNumbers[1].trim();
            //   msg 'zz11: '+companyIDPartyIdentificationID+' refNum: '+refNum+' refOIB: '+refOIB;
            
            // Supplier name
            suppName= "";
            if (Contains(suppPartyData, "PartyLegalEntity")) {
                suppName = suppPartyData["PartyLegalEntity"]["RegistrationName"];
            } else {
                //suppName = suppPartyData["PartyLegalEntity"]["CompanyName"];
                //find name from NKSCPART
            }
            NKPR_GL_CUSNME = "";
            if (suppName != "") {
                NKPR_GL_CUSNME = suppName;
            }  

            //odrediti OIB dobavljača iz /Invoice/cac:AccountingSupplierParty/cac:Party/cac:PartyTaxScheme/cbc:CompanyID
            if (Contains(suppPartyData, "PartyTaxScheme")) {
                partyTaxScheme = suppPartyData["PartyTaxScheme"];
                if (Contains(partyTaxScheme, "CompanyID")) {
                    OIBSupp = partyTaxScheme["CompanyID"];
                }
            }
            //tu sad imamo OIB dobavljača i broj računa dobavljača; sada provjeriti da li je taj račun već unesen za tog dobavljača
                sqlQueryString = "select NKPR_GL_JMBG, NKPR_GL_DESC from " + strtrim(databaseName) + ".dbo.NKNAERGL WHERE NKPR_GL_JMBG = '" + OIBSupp + "' AND NKPR_GL_DESC = '" + NKPR_GL_DESC + "'";
                //try
                //{
                    sqlOIBInvoicenum = sqlQuery(sqlQueryString);
                //}
                //catch(ex)
                //{
                //}
                
            if (size(sqlOIBInvoicenum) > 1)
            {
                if(copyIndicator != "true"){
                    //ako je copyIndicator ne postoji ili je false, onda je to kopija računa i dozvoliti unos
                    //ako nije, onda javiti da je račun već unesen
                }else{
                    //tu bisada trebalo u originalni račun pod tim brojem spremiti u MemoX da je taj račun dobio kopiju i koji je broj te kopije
                    memoX = "Račun s OIB-om dobavljača " + OIBSupp + " i brojem računa dobavljača " + NKPR_GL_DESC + " je već unesen u bazu pod brojem računa: " + sqlOIBInvoicenum[1][1].trim() + " Došla je kopija računa.\n";
                    return;
                }                    
            }
            // Supplier address
            if (Contains(suppPartyData, "PostalAddress")) { 
                suppAddress = suppPartyData["PostalAddress"];
                if (suppAddress != null && suppAddress != "") {
                    if (Contains(suppAddress, "StreetName")) {NKPR_GL_CUSA1 = suppAddress["StreetName"]};
                    if (Contains(suppAddress, "CityName")) {NKPR_GL_CUSCTY = suppAddress["CityName"]};
                    if (Contains(suppAddress, "PostalZone")) {NKPR_GL_CUSZIP = suppAddress["PostalZone"]};
                    if (Contains(suppAddress, "Country")) {NKPR_GL_CUSST = suppAddress["Country"]["IdentificationCode"]};
                    if (Contains(suppAddress, "Country")) {NKPR_GL_DRZAVA = suppAddress["Country"]["IdentificationCode"]};
                }
            }
        }
        //msg("11121: "+companyIDPartyIdentificationID);
        NKPR_GL_CUSCOD = "";
            if (refNum == "9934") { 
                // OIB
                if (OIBSupp == "") {
                    OIBSupp = refOIB;
                }
                // NKSCPART - nađi dobavljača po OIB-u/GLN-u i uzmi šifru dobavljača
                // ako ne postoji, kreiraj novog dobavljača
                sqlQueryString = "select NKSC_PARTCODE, NKSC_PARTNAME, NKSC_RO, NKSC_ADD1, NKSC_CITY, NKSC_ZIP, NKSC_drzava, NKSC_SIFRA  from " + strtrim(databaseName) + ".dbo.NKSCPART WHERE NKSC_SIFRA = '" + OIBSupp + "'";
                try
                {
                    sqlPartner = sqlQuery(sqlQueryString);
                }
                catch(ex)
                {
                    MessageBox("Greška čitanja NKSCPART:\n" + ex);
                    // Ovo je novi dobavljač, treba ga unijeti ili prekinuti unos ovog računa i dati poruku na ekranu
                    //exit;
                }
            } elif (refNum == "0088") { // GLN
                GLNSupp = refOIB;
                // NKSCPART - nađi dobavljača po OIB-u/GLN-u i uzmi šifru dobavljača
                // ako ne postoji, kreiraj novog dobavljača
                sqlQueryString = "select NKSC_PARTCODE, NKSC_PARTNAME, NKSC_RO, NKSC_ADD1, NKSC_CITY, NKSC_ZIP, NKSC_drzava, NKSC_SIFRA  from " + strtrim(databaseName) + ".dbo.NKSCPART WHERE NKSC_SOP = '" + GLNSupp + "'";
                try
                {
                    sqlPartner = sqlQuery(sqlQueryString);
                }
                catch(ex)
                {
                    MessageBox("Greška čitanja NKSCPART:\n" + ex);
                    // Ovo je novi dobavljač, treba ga unijeti ili prekinuti unos ovog računa i dati poruku na ekranu
                    //exit;
                }
            } else {
                //Ovo je nepodržano za sada, staviti poruku i prekinuti unos ovog računa
                MessageBox("Nepodržani identifikator dobavljača: " + companyIDPartyIdentificationID + ". Račun neće biti uvezen.");
                return;
            }
                if (size(sqlPartner) > 1)
                {
                 /*   cuscod = sqlPartner[1][0].trim(); //     NKSC_PARTCODE
                    partname = sqlPartner[1][1].trim(); //     NKSC_PARTNAME
                    ro = sqlPartner[1][2].trim(); //     NKSC_ro    
                    cusa1 = sqlPartner[1][3].trim(); //  NKSC_ADD1
                    cuscty = sqlPartner[1][4].trim(); // NKSC_CITY
                    cuszip = sqlPartner[1][5]; // NKSC_ZIP
                    drzava = sqlPartner[1][6].trim(); // NKSC_drzava
                    jmbg = sqlPartner[1][7].trim(); // NKSC_sifra
                    */
                    //Izgleda bug u CSCS_WPF - ako preuzme vrijednosti iz sqlPartner resultseta, izbriše cijeli dictionary headerData???
                    //Rješenje je da ih prvo spremimo u varijable, pa onda iz njih u headerData
                    NKPR_GL_CUSCOD = sqlPartner[1][0].trim(); //     NKSC_PARTCODE
                    NKPR_GL_CUSNME = sqlPartner[1][1].trim(); //     NKSC_PARTNAME
                    NKPR_GL_ro = sqlPartner[1][2].trim(); //     NKSC_ro
                    NKPR_GL_CUSA1 = sqlPartner[1][3].trim(); //  NKSC_ADD1
                    NKPR_GL_CUSCTY = sqlPartner[1][4].trim(); // NKSC_CITY
                    NKPR_GL_CUSZIP = sqlPartner[1][5]; // NKSC_ZIP
                    NKPR_GL_DRZAVA = sqlPartner[1][6].trim(); // NKSC_drzava
                    NKPR_GL_JMBG  = sqlPartner[1][7].trim(); // NKSC_sifra

                }else{
                    //msg( "Ovo je novi partner! Molim da ga otvorite u matičnim podacima partnera:\n" + 
                    //return;
                }   
            if (OIBSupp != "") {
                NKPR_GL_JMBG = OIBSupp;
            } elif (GLNSupp != "") {
                MemoX += "GLN: " + GLNSupp + "\n";
            }else {
               return;
            }
        // Customer information from AccountingCustomerParty
        //this is own company data
        custParty = docData["AccountingCustomerParty"];
        if (custParty != null && custParty != "") {
            custPartyData = custParty;
            if (Contains(custParty, "Party")) {
                custPartyData = custParty["Party"];
            }
            // Customer OIB/GLN
            custCompanyID = custPartyData["PartyIdentification"]["ID"];
            refNumbers = custCompanyID.split(":");
            //refIdx = 0;
            refNum = refNumbers[0].trim();
            refOIB = refNumbers[1].trim();
            if (refNum == "9934") { 
                // OIB
                if (CompanyOIB != refOIB){
                    MessageBox("OIB kupca u računu (" + refOIB + ") ne odgovara OIB-u naše tvrtke (" + CompanyOIB + "). Račun neće biti uvezen.");
                    return;
                }
            }            
            if (custCompanyID == "") {
                custCompanyID = custPartyData["PartyLegalEntity"]["CompanyID"];
            }
        }
        // Delivery information
        if (Contains(docData, "Delivery")) {
            delivery = docData["Delivery"];
            if (delivery != null && delivery != "") {
                if (Contains(delivery, "DeliveryLocation")) {
                    deliveryLocation = delivery["DeliveryLocation"];
                    if (deliveryLocation != null && deliveryLocation != "") {
                        if (Contains(deliveryLocation, "ID")) {
                            deliveryID = deliveryLocation["ID"];
                        } else {
                            deliveryID = "";
                        }
                        if (deliveryID != "") {
                            // Check if it's GLN (13 characters) or internal code
                            if (deliveryID.length == 13) {
                                //tu trebamo provjerit samo da li je to mjesto isporuke predviđeno kod nas u NKSPADRS!!!!
                                //NKPR_AD_GLN = deliveryID;
                            } else {
                                NKPR_GL_SHPCOD = deliveryID;
                            }
                        }
                        // Delivery address
                        if (Contains(deliveryLocation, "Address")) {
                            deliveryAddr = deliveryLocation["Address"];
                        } else {
                            deliveryAddr = {};
                        }
                        if (deliveryAddr != null && deliveryAddr != "") {
                            if (Contains(deliveryAddr, "StreetName")) {NKPR_GL_SHPA1 = deliveryAddr["StreetName"]};
                            if (Contains(deliveryAddr, "CityName")) {NKPR_GL_SHPCTY = deliveryAddr["CityName"]};
                            if (Contains(deliveryAddr, "PostalZone")) {NKPR_GL_SHPZIP = deliveryAddr["PostalZone"]};
                            if (Contains(deliveryAddr, "Country")) {NKPR_GL_SHPST = deliveryAddr["Country"]["IdentificationCode"]};
                        }
                    }
                }
            
                // Delivery party
                if (Contains(delivery, "DeliveryParty")) {
                    deliveryParty = delivery["DeliveryParty"];
                    if (deliveryParty != null && deliveryParty != "") {
                        NKPR_GL_SHPNME = deliveryParty["PartyName"]["Name"];
                    }
                } else {
                    deliveryParty = {};
                }
            }
        }
            // Payment information
        paymentMeans = docData["PaymentMeans"];
        if (paymentMeans != null && paymentMeans != "") {
            NKPR_GL_SIF_PL = paymentMeans["PaymentMeansCode"];
            if (NKPR_GL_CUSCOD != "") {
                sql_bank = "SELECT NKSC_ZR_KONTO, NKSC_ZR_NAZIV, NKSC_ZR_BANKA FROM " + databaseName + ".dbo.NKSCZIRO WHERE NKSC_ZR_CODE = @p1;";
                sqlParams = {};
                sqlParams.Add({"@p1", NKPR_GL_CUSCOD});
                bankRes = sqlQuery(sql_bank, sqlParams);
                if (Size(bankRes) >= 2) {
                    NKSC_ZR_KONTO = bankRes[1][0].trim();
                    NKSC_ZR_NAZIV = bankRes[1][1].trim();
                    NKSC_ZR_BANKA = bankRes[1][2].trim();
                    if (contains(paymentMeans,"PayeeFinancialAccount")) {
                        paymentAccount = paymentMeans["PayeeFinancialAccount"];
                    } else {
                        paymentAccount = {};
                    }
                    if (NKSC_ZR_KONTO == paymentAccount["ID"]) {
                        NKPR_GL_RZRVA1 = NKSC_ZR_BANKA;
                    }
                }
            } else {
                    if (contains(paymentMeans,"PayeeFinancialAccount")) {
                        paymentAccount = paymentMeans["PayeeFinancialAccount"];
                        NKPR_GL_SIGNATU = paymentAccount["ID"];
                    } else {
                        paymentAccount = {};
                    }
                    //NKSC_ZR_KONTO = "";
                    //NKSC_ZR_NAZIV = "";
                    //NKSC_ZR_BANKA = "";
            }
            if (Contains(paymentMeans, "PaymentID")) {
                paymentID = paymentMeans["PaymentID"];
                if (Contains(paymentID, " ")) {
                    paymentParts = paymentID.split(" ");
                    NKPR_GL_MODEL = paymentParts[0];
                    if (Size(paymentParts) > 1) {
                        NKPR_GL_POZIV = paymentParts[1];
                    }
                }
            }
        }
        // Monetary totals
        legalMonTotal = docData["LegalMonetaryTotal"];
        if (legalMonTotal != null && legalMonTotal != "") {
            //NKPR_GL_LINETOTAL = ParseDecimal(legalMonTotal["LineExtensionAmount"]);
            NKPR_GL_SUBTOT = ParseDecimal(legalMonTotal["TaxExclusiveAmount"]);
            NKPR_GL_TOTAL = ParseDecimal(legalMonTotal["TaxInclusiveAmount"]);
            NKPR_GL_TAXAMT = NKPR_GL_TOTAL-NKPR_GL_SUBTOT;
        }
        // Notes
        if (Contains(docData, "Note")) {
            note = docData["Note"];
            if (note != "") {
                /*
                // Parse referenced invoices from note, za slučaj kada dobavljač šalje račun koji je napravljen sa našim programom Asconto ERP
                refStartPos = IndexOf(note, "#REF(");
                if (refStartPos >= 0) {
                    refEndPos = IndexOf(note, ")", refStartPos);
                    if (refEndPos >= 0) {
                        refContent = Substring(note, refStartPos + 5, refEndPos - refStartPos - 5);
                        refNumbers = refContent.Split(","); // Split by comma 
                        if (Size(refNumbers) == 1) {
                            NKPR_GL_REZ3 = refNumbers[1].trim();
                        } elif (Size(refNumbers) > 1){
                            //put all data to MEMO field separated by comma
                            MemoX += "Referencirani računi: ";
                        } else {
                            //no valid ref found
                        }
                    }
                }
                */
                //tu sad treba spremit cijeli note u MemoH ili MemoF ili u linije ili negdje drugdje ako treba
            }
        }

        // Extract and save notes to NKNAOPIS table
       ExtractAndSaveNotes(docData);

        // Extract and save attachments to disk and NKSYPICT table
        ExtractAndSaveAttachments(invoiceDict, docType);

        // Billing references
        if (Contains(docData, "BillingReference")) {
            billingRef = docData["BillingReference"];
            billingRefID = billingRef["InvoiceDocumentReference.ID"];
            if (billingRefID != "" && NKPR_GL_REZ3 == "") {
                NKPR_GL_REZ3 = ParseInvoiceNumber(billingRefID);
            }
        } else {
            billingRef = {};
        }
        return true;
        
    } catch (error) {
        MessageBox("Greška prilikom izvlačenja podataka zaglavlja: " + error);
        return null;
    }
}

// Add this function after ExtractHeaderDataFromDict function

// -----------------------------------------------------------
// Save note to NKNAOPIS table and return reference number
// -----------------------------------------------------------
function SaveNoteToNKNAOPIS(noteText) {
    try {
        if (noteText == "" || noteText == null) {
            return 0;
        }
        
        // Get next available KPPR_OP_BROJ
        sql_max_note = "SELECT ISNULL(MAX(KPPR_OP_BROJ), 0) AS maxNum FROM " + databaseName + ".dbo.NKNAOPIS";
        maxRes = sqlQuery(sql_max_note);
        
        nextNoteNum = 1;
        if (Size(maxRes) >= 2) {
            nextNoteNum = maxRes[1][0] + 1;
        }
        
        // Split note text into chunks of 75 characters
        noteLength = noteText.length;
        chunkSize = 75;
        lineNum = 1;
        startPos = 0;
        
        while (startPos < noteLength) {
            // Calculate chunk length (75 chars or remaining text if less)
            remainingLength = noteLength - startPos;
            currentChunkSize = (remainingLength > chunkSize) ? chunkSize : remainingLength;
            
            // Extract chunk
            chunk = Substring(noteText, startPos, currentChunkSize);
            
            // Insert chunk into KPPROPIS
            sql_insert_note = "INSERT INTO " + databaseName + ".dbo.NKNAOPIS (KPPR_OP_BROJ, KPPR_OP_LIN, KPPR_OP_TEXT) " +
                            "VALUES (@p1, @p2, @p3);";
            sqlParams = {};
            sqlParams.Add({"@p1", nextNoteNum});
            sqlParams.Add({"@p2", lineNum});
            sqlParams.Add({"@p3", chunk});
            
            result = SqlNonQuery(sql_insert_note, sqlParams);
            
            if (result == 0) {
                throw "Failed to insert note chunk at line " + lineNum;
            }
            
            // Move to next chunk
            startPos += chunkSize;
            lineNum++;
        }
        
        msg("Note saved with reference number: " + nextNoteNum + " (" + (lineNum - 1) + " lines)");
        return nextNoteNum;
        
    } catch (error) {
        MessageBox("Greška pri spremanju napomene: " + error);
        return 0;
    }
}

// -----------------------------------------------------------
// Extract and save notes from document
// -----------------------------------------------------------
function ExtractAndSaveNotes(docData) {
    try {
        NKPR_GL_BROPIS = 0;
        NKPR_GL_BROPIS1 = 0;
        
        // Check if Note element exists
        if (!Contains(docData, "Note")) {
            return; // No notes to process
        }
        
        noteValue = docData["Note"];
        
        if (noteValue == null || noteValue == "") {
            return; // Empty note
        }
        
        msg("=== PROCESSING NOTES ===");
        msg("Note type: " + noteValue.type());
        
        // Handle single note (STRING or OBJECT)
        if (noteValue.type() == "STRING") {
            // Single note as simple string
            NKPR_GL_BROPIS = SaveNoteToNKNAOPIS(noteValue);
            msg("Saved first note with reference: " + NKPR_GL_BROPIS);
        }
        elif (noteValue.type() == "OBJECT" && !IsArray(noteValue)) {
            // Single note as object (might have #text)
            noteText = "";
            if (Contains(noteValue, "#text")) {
                noteText = noteValue["#text"];
            } else {
                noteText = String(noteValue);
            }
            NKPR_GL_BROPIS = SaveNoteToNKNAOPIS(noteText);
            msg("Saved first note with reference: " + NKPR_GL_BROPIS);
        }
        elif (noteValue.type() == "ARRAY") {
            // Multiple notes as array
            if (noteValue.size() > 0) {
                // First note
                firstNote = noteValue[0];
                firstNoteText = "";
                
                if (firstNote.type() == "STRING") {
                    firstNoteText = firstNote;
                } elif (Contains(firstNote, "#text")) {
                    firstNoteText = firstNote["#text"];
                } else {
                    firstNoteText = String(firstNote);
                }
                
                NKPR_GL_BROPIS = SaveNoteToNKNAOPIS(firstNoteText);
                msg("Saved first note with reference: " + NKPR_GL_BROPIS);
            }
            
            if (noteValue.size() > 1) {
                // Second note
                secondNote = noteValue[1];
                secondNoteText = "";
                
                if (secondNote.type() == "STRING") {
                    secondNoteText = secondNote;
                } elif (Contains(secondNote, "#text")) {
                    secondNoteText = secondNote["#text"];
                } else {
                    secondNoteText = String(secondNote);
                }
                
                NKPR_GL_BROPIS1 = SaveNoteToNKNAOPIS(secondNoteText);
                msg("Saved second note with reference: " + NKPR_GL_BROPIS1);
            }
            
            // If there are more than 2 notes, log a warning
            if (noteValue.size() > 2) {
                //ako ima više od va notesa, treba ih spremiti u istu tablu NKNAOPIS i na isti način, ali svaki notes treba otvorit novu liniju u NKNAERLN i referenti broj spremiti u NKPR_LN_BROPI
                msg("WARNING: Document contains " + noteValue.size() + " notes, but only first 2 were saved");
            }
        }
        
        msg("=== NOTES PROCESSING COMPLETE ===");
        msg("NKPR_GL_BROPIS: " + NKPR_GL_BROPIS);
        msg("NKPR_GL_BROPIS1: " + NKPR_GL_BROPIS1);
        
    } catch (error) {
        MessageBox("Greška pri obradi napomena: " + error);
    }
}

// Extract line items from Dictionary
function ExtractLineItemsFromDict(invoiceDict, docType) {
    try {
        lineItems = {};
        // Get the root document data
        docData = invoiceDict;
        if (docType == "S" && invoiceDict.Contains("Invoice")) {
            docData = invoiceDict["Invoice"];
        } elif (docType == "R" && invoiceDict.Contains("CreditNote")) {
            docData = invoiceDict["CreditNote"];
        } elif (docType == "T" && invoiceDict.Contains("DebitNote")) {
            docData = invoiceDict["DebitNote"];
        }
        
        // Determine line element name based on document type
        lineElementName = "";
        quantityElementName = "";
        if (docType == "S") {
            lineElementName = "InvoiceLine";
            quantityElementName = "InvoicedQuantity";
        } elif (docType == "R") {
            lineElementName = "CreditNoteLine";
            quantityElementName = "CreditedQuantity";
        } elif (docType == "T") {
            lineElementName = "DebitNoteLine";
            quantityElementName = "DebitedQuantity";
        }
        
        // Get line items array
       
        // MSG("docData:\n" + docData);
        // MSG("lineElementName:\n" + lineElementName);

        // msg("docData:\n" + docData);
        // msg("lineelementName:\n" + lineelementName);
        //linesArray = docData[lineElementName]; 
        
        // linesArray = GetDictValue2(docData, lineElementName); 
        // linesArray = docData["InvoiceLine"]; 

        if(ArrayOrDict(documentDict[documentType][lineElementName]) == "array"){
            msg("It's an array");
            for(mmm = 0; mmm < Size(documentDict[documentType][lineElementName]); mmm++){
                // msg("LINE " + mmm + ": " + documentDict[documentType][lineElementName][mmm]);
                // lin = documentDict[documentType][lineElementName][mmm];
                // MSG("LIN: " + lin);
                
                //MSG("AAAA: " + quantityElementName+" LINE DATA: " + linesArray[i]);
                lineData = ExtractSingleLineFromDict(documentDict[documentType][lineElementName][mmm], quantityElementName);
                //MSG("Processing line " + i + ": " + lineData);
                if (lineData != null) {
                    // MSG(lineData);
                    // MSG(lineItems);
                    lineItems.Add(lineData);
                    // MSG(lineItems);
                }
            }                
        }else{
            msg("It's a dict");
            // MSG("DICT: " + documentDict[documentType][lineElementName]);

            lineData = ExtractSingleLineFromDict(documentDict[documentType][lineElementName], quantityElementName);
            if (lineData != null) {
                lineItems.Add(lineData);
            }
        }



        // MSG(documentDict[documentType][lineElementName]); 
        
        // linesArray = documentDict[documentType][lineElementName];
        // MSG(linesArray);

        // MSG(documentDict[documentType][lineElementName]); 
        

        //msg ("LINES ARRAY: " + linesArray);    
        // if (linesArray == null || linesArray == "") {
        //     return {}; // Return empty array if no lines found
        // }
        // linArrType = linesArray.type()

        //Msg("linArrType: " + linArrType);
        //OVO TREBA RIJEŠIT - NE VRAĆA BROJ LINIJA KAKO TREBA, pa ne odradi sve linije i tu negdje pada u grešku
        // if (linArrType == "ARRAY") {
        //     //msg ("MULTIPLE LINES DETECTED");
        //     // Handle multiple lines
        //     lineItems = {};
            
        //     // Multiple lines
        //     for (i = 0; i < linesArray.size(); i++) {
        //         //MSG("AAAA: " + quantityElementName+" LINE DATA: " + linesArray[i]);
        //         lineData = ExtractSingleLineFromDict(linesArray[i], quantityElementName);
        //         //MSG("Processing line " + i + ": " + lineData);
        //         if (lineData != null) {
        //             lineItems.Add(lineData);
        //         }
        //     }
        // } else {
        //     // Single line
        // //MSG("Processing single line: " + lineData);    
        //     lineData = ExtractSingleLineFromDict(linesArray, quantityElementName);
        //     if (lineData != null) {
        //         lineItems.Add(lineData);
        //     }
        // }
        
      //msg ("FINAL LINE ITEMS: " + lineItems);   

        // MSG("LINE ITEMS:\n" + lineItems);

        // x123123 =  lineItems;
        // msg("x123123:\n" + x123123);

        // MSG("LINE ITEMS:\n" + lineItems);


        // return lineItems;
        return;
        
    } catch (error) {
        MessageBox("Greška prilikom izvlačenja stavki: " + error);
        return null;
    }
}

// Extract single line item data from Dictionary
function ExtractSingleLineFromDict(lineDict, quantityElementName) {
    try {
        lineData = {};
        
        // LINE DICT JE JEDNA LINIJA

        // MSG(lineDict);

        // MSG("ID:\n\n" + lineDict["ID"]);


        // Basic line information
        // lineData["NKPR_LN_BR_LN"] = GetDictValue(lineDict, "ID");

        lineData["NKPR_LN_BR_LN"] = lineDict["ID"];

    // msg ("LINE ID: " + lineData["NKPR_LN_BR_LN"]);

        // Quantity and unit
        // quantity = GetDictValue(lineDict, quantityElementName);
        quantity = lineDict[quantityElementName]["@text"];
        if (quantity != "") {
            lineData["NKPR_LN_PQTY"] = ParseDecimal(quantity);
            
            // Unit code (might be in attributes - handle as needed)
            // unitCode = GetDictValue(lineDict, quantityElementName + ".unitCode");
            unitCode = lineDict[quantityElementName]["@attributes"]["unitCode"];
            // MSG("UNIT CODE RAW: " + unitCode);
            lineData["NKPR_LN_JEDMJ"] = GetUnitCodeFromUN(unitCode);
        }
        
        // Line amount
        //lineData["NKPR_LN_AMT"] = ParseDecimal(GetDictValue(lineDict, "LineExtensionAmount"));
        // lineData["NKPR_LN_AMT"] = ParseDecimal(GetDictValue(lineDict, "LineExtensionAmount"));
        lineData["NKPR_LN_AMT"] = ParseDecimal(lineDict["LineExtensionAmount"]["@text"]);
        // MSG("LINE AMT RAW: " + lineData["NKPR_LN_AMT"]);

    //msg ("LINE AMT: " + lineData["NKPR_LN_AMT"]);    
        // Item information
        // item = GetDictValue(lineDict, "Item");
        item = lineDict["Item"];
        // MSG("ITEM RAW: " + item);

        if (item != null && item != "") {
            lineData["NKPR_LN_PDESC"] = item["Name"];
            // msg("LINE DESC: " + lineData["NKPR_LN_PDESC"]);
            
            // Product code - try different locations
            // productCode = GetDictValue(item, "BuyersItemIdentification.ID");
            if(Contains(item, "BuyersItemIdentification")){
                MSG("25561: NEEDS TESTING !!!");
                bii = item["BuyersItemIdentification"];
                biiId = bii["ID"];    
                lineData["NKPR_LN_PCODE"] = biiId;       
            }           
           
            if(Contains(item, "StandardItemIdentification")){
                MSG("25562: NEEDS TESTING !!!");
                sii = item["StandardItemIdentification"];
                siiId = sii["ID"];    
                lineData["NKPR_LN_BARCODE"] = siiId;       
            }           
                       

            // if (productCode == "") {
            //     productCode = GetDictValue(item, "SellersItemIdentification.ID");
            // }
            // lineData["NKPR_LN_PCODE"] = productCode;


            // msg ("LINE Product: " + lineData["NKPR_LN_PCODE"]+ " DESC: " + lineData["NKPR_LN_PDESC"]);    
            
            // Tax information
            // taxCategory = GetDictValue(item, "ClassifiedTaxCategory");
            taxCategory = item["ClassifiedTaxCategory"];
            // MSG("TAX CATEGORY RAW: " + taxCategory);
            taxPercent = taxCategory["Percent"];
            lineData["NKPR_LN_PRNPR"] = taxPercent;
            // MSG("percent RAW: " + percent);
            // if (taxCategory != null && taxCategory != "") {
            //     taxPercent = ParseDecimal(GetDictValue(taxCategory, "Percent"));
            //     lineData["NKPR_LN_PRNPR"] = taxPercent;
            //     //lineData["NKPR_LN_TXBLE"] = (taxPercent > 0) ? "Y" : "N";
            // }
            //msg ("TAX PERCENT: " + lineData["NKPR_LN_PRNPR"]);        
        }
        
        // Price information
        // price = GetDictValue(lineDict, "Price");
        price = lineDict["Price"];
        // Msg("PRICE RAW: " + price);

        // if (price != null && price != "") {
        lineData["NKPR_LN_PPRCE"] = ParseDecimal(price["PriceAmount"]["@text"]);
        // msg("LINE PRICE: " + lineData["NKPR_LN_PPRCE"]);
        // }
        
        // Allowances and charges
        // allowanceCharge = GetDictValue(lineDict, "AllowanceCharge");
        
        if(Contains(lineDict, "AllowanceCharge")){
            MSG("25563: NEEDS IMPLEMENTATION !!!");
            allowanceCharge = lineDict["AllowanceCharge"];
            MSG("ALLOWANCE CHARGE RAW: " + allowanceCharge);
            // IMPLEMENT
        }
        // allowanceCharge = GetDictValue(lineDict, "AllowanceCharge");
        // if (allowanceCharge != null && allowanceCharge != "") {
        //     // Handle both single and multiple allowance/charge entries
        //     if (IsArray(allowanceCharge)) {
        //         for (i = 0; i < Size(allowanceCharge); i++) {
        //             ProcessAllowanceCharge(allowanceCharge[i], lineData);
        //         }
        //     } else {
        //         ProcessAllowanceCharge(allowanceCharge, lineData);
        //     }
        // }


        //msg ("LINE PRICE: " + lineData["NKPR_LN_PPRCE"]);   
        // Notes
        // lineNote = GetDictValue(lineDict, "Note");
        // lineNote = GetDictValue(lineDict, "Note");
        // if (lineNote != "") {
        //     //lineData["NKPR_LN_NOTE"] = lineNote;
        // }
        
        // Extract line item attachment if present
        lineAttachmentNum = ExtractLineItemAttachments(lineDict, lineData["NKPR_LN_BR_LN"]);
        if (lineAttachmentNum > 0) {
            lineData["NKPR_LN_SASTAV"] = lineAttachmentNum;
        } else {
            if(!Contains(lineData, "NKPR_LN_SASTAV")) {
                lineData["NKPR_LN_SASTAV"] = 0;
            }
        }
        
    //msg ("FINAL LINE DATA: " + lineData);    
        return lineData;
        
    } catch (error) {
        MessageBox("Greška prilikom izvlačenja stavke: " + error);
        return null;
    }
}

// Process allowance/charge for line item
function ProcessAllowanceCharge(allowanceChargeDict, lineData) {
    chargeIndicator = GetDictValue(allowanceChargeDict, "ChargeIndicator");
    amount = ParseDecimal(GetDictValue(allowanceChargeDict, "Amount"));
    
    if (chargeIndicator == "false" && amount > 0) {
        // This is an allowance (discount)
        lineData["NKPR_LN_POPL"] = amount;
        
        // Calculate discount percentage
        grossAmount = lineData["NKPR_LN_PQTY"] * lineData["NKPR_LN_PPRCE"];
        if (grossAmount > 0) {
            lineData["NKPR_LN_PDISC"] = (amount / grossAmount) * 100;
        }
    } elif (chargeIndicator == "true" && amount > 0) {
        // This is a charge - handle as negative discount
        lineData["NKPR_LN_POPL"] = -amount;
        
        grossAmount = lineData["NKPR_LN_PQTY"] * lineData["NKPR_LN_PPRCE"];
        if (grossAmount > 0) {
            lineData["NKPR_LN_PDISC"] = -(amount / grossAmount) * 100;
        }
    }
}


function end(){
    cursor("dflt");
    MessageBox("Kraj");
    exit;
}

// Helper function to check if value is an array
function IsArray(value) {
    return (value != null && value.type() == "object" && value.Length != undefined);
}

// Helper function to check if value is a string
function IsString(value) {
//msg ("HHHH Value: " + value+" TYPE: " + value.type());    
    return (value.type() == "STRING");
}

// Helper function to check if value is a primitive (leaf) value (not a dictionary/object)
// Primitive types include: STRING, INTEGER, DOUBLE, BOOLEAN, etc.
// Non-primitive types: OBJECT (dictionaries), ARRAY
function IsPrimitiveValue(value) {
    if (value == null || value == "") {
        return true; // Treat null/empty as primitive
    }
    
    valueType = value.type();
    
    // Check if it's NOT a complex type (object/dictionary or array)
    // Primitive types: STRING, INTEGER, DOUBLE, BOOLEAN, etc.
    if (valueType == "OBJECT" || valueType == "ARRAY") {
        return false; // Complex type
    }
    
    return true; // It's a primitive type (string, number, boolean, etc.)
}

// Helper function to parse decimal values (enhanced)
function ParseDecimal(value) {
    if (value == "" || value == null) {
        return 0.00;
    }
    
    // If it's already a primitive value (number or string), convert directly
    if (IsPrimitiveValue(value)) {
        // Check if it's already numeric
        valueType = value.type();
        if (valueType == "DOUBLE" || valueType == "INTEGER") {
            return Double(value); // Already a number, just ensure it's double
        }
        // It's a string or other primitive, convert to double
        return Double(value);
    }
    
    // Handle dictionary/object values with #text element
    if (value.Contains("#text")) {
        return Double(value["#text"]);
    }
    
    // Fallback: try to convert to string then to double
    return Double(String(value));
}

// Helper function to safely get value from dictionary with dot notation support
function GetDictValue(dict, key) {
    if (dict == null || IsPrimitiveValue(dict)) {
        return dict; // Return the primitive value directly (string, number, boolean, etc.)
    }
    
    if (!Contains(key, ".")) {
        // Simple key
        if (Contains(dict, key)) {
            return dict[key];
        } else {
            return "";
        }
    } else {
        // Nested key with dot notation (e.g., "Item.Name")
        keys = Split(key, ".");
        currentDict = dict;
        
        for (i = 0; i < Size(keys); i++) {
            currentKey = keys[i];
            
            if (currentDict == null || IsPrimitiveValue(currentDict)) {
                return ""; // Hit a primitive value before reaching the end of the key path
            }
            
            if (Contains(currentDict, currentKey)) {
                currentDict = currentDict[currentKey];
            } else {
                return "";
            }
        }
        
        return currentDict;
    }
}
// Helper function to safely get value from dictionary with dot notation support
function GetDictValue2(dict, key) {
    if (dict == null || IsPrimitiveValue(dict)) {
        return dict; // Return the primitive value directly (string, number, boolean, etc.)
    }
msg("KKKK DICT: " + dict+" KEY: " + key);    
    if (!Contains(key, ".")) {
        // Simple key
        if (Contains(dict, key)) {
   msg("JJJJ VALUE: " + dict[key]);         
            return dict[key];
        } else {
            return "";
        }
    } else {
        // Nested key with dot notation (e.g., "Item.Name")
        keys = key.Split(".");
        currentDict = dict;
        
        for (i = 0; i < keys.size(); i++) {
            currentKey = keys[i];
            
            if (currentDict == null || IsPrimitiveValue(currentDict)) {
                return ""; // Hit a primitive value before reaching the end of the key path
            }
            
            if (Contains(currentDict, currentKey)) {
                currentDict = currentDict[currentKey];
            } else {
                return "";
            }
        }
        
        return currentDict;
    }
}

// Import header data into NKNAERGL table
function ImportHeaderDataToERGL(docType) {
    try {
        // Generate new record ID
        newRecordId = GetNextRecordId("NKNAERGL");
        NKPR_GL_BRPON = newRecordId;
        //invDate = now("yyyy-MM-dd").toString();
        //timeCreated = now("HH:mm:ss").toString();
        // Prepare SQL insert statement for NKNAERGL table
        sql_insert = "INSERT INTO " + databaseName + ".dbo.NKNAERGL (";
        sql_insert += "NKPR_GL_BRPON, NKPR_GL_OZNAKA, NKPR_GL_INVDTE, NKPR_GL_TIMECR, ";
        sql_insert += "NKPR_GL_DVO, NKPR_GL_NOKAM, NKPR_GL_ESD,  NKPR_GL_SIFDVZ, ";
        sql_insert += "NKPR_GL_JMBG, NKPR_GL_CUSNME, NKPR_GL_CUSA1, NKPR_GL_CUSCTY, ";
        sql_insert += "NKPR_GL_CUSZIP, NKPR_GL_CUSST, ";
        sql_insert += "NKPR_GL_SHPCOD, NKPR_GL_SHPNME, NKPR_GL_SHPA1, NKPR_GL_SHPCTY, ";
        sql_insert += "NKPR_GL_SHPZIP, NKPR_GL_SHPST,";
        sql_insert += "NKPR_GL_SIF_PL, NKPR_GL_MODEL, NKPR_GL_POZIV, NKPR_GL_DATPRI, ";
        sql_insert += "NKPR_GL_TAXAMT, NKPR_GL_TOTAL, NKPR_GL_DESC,";
        sql_insert += "NKPR_GL_BROPIS1, NKPR_GL_REZ3, NKPR_GL_DATECR, NKPR_GL_DRZAVA, ";
        sql_insert += "NKPR_GL_POSRED";
        sql_insert += ") VALUES (";
        sql_insert += "@brpon, @docType, @invDate, @timeCreated, ";
        sql_insert += "@dvo, @nokam, @taxPointDate, @currency, ";
        sql_insert += "@custOIB, @custName, @custAddress, @custCity, ";
        sql_insert += "@custZip, @custState, ";
        sql_insert += "@shpCode, @shpName, @shpAddress, @shpCity, ";
        sql_insert += "@shpZip, @shpState, ";
        sql_insert += "@payment, @model, @poziv, @datpri, ";
        sql_insert += "@taxTotal, @total, @glDesc, ";
        sql_insert += "@note, @rez3, @created, @country, @posred";
        sql_insert += ");";
        
        // Prepare parameters
        sqlParams = {};
        // sqlParams.Add({"@invNum", NKPR_GL_NUM});
        sqlParams.Add({"@brpon", newRecordId});
        sqlParams.Add({"@docType", NKPR_GL_OZNAKA});
        sqlParams.Add({"@invDate", NKPR_GL_INVDTE});
        sqlParams.Add({"@timeCreated", NKPR_GL_TIMECR});
        
        sqlParams.Add({"@dvo", NKPR_GL_INVDTE});
        sqlParams.Add({"@nokam", NKPR_GL_NOKAM});
        
        sqlParams.Add({"@taxPointDate", NKPR_GL_ESD});

        sqlParams.Add({"@currency", NKPR_GL_SIFDVZ});
        sqlParams.Add({"@custOIB", NKPR_GL_JMBG});
        sqlParams.Add({"@custName", NKPR_GL_CUSNME});
        sqlParams.Add({"@custAddress", NKPR_GL_CUSA1});
        sqlParams.Add({"@custCity", NKPR_GL_CUSCTY});
        sqlParams.Add({"@custZip", NKPR_GL_CUSZIP});
        sqlParams.Add({"@custState", NKPR_GL_CUSST});
        //sqlParams.Add({"@suppOIB", NKPR_GL_SUPPOIB});
        sqlParams.Add({"@shpCode", NKPR_GL_SHPCOD});
        sqlParams.Add({"@shpName", NKPR_GL_SHPNME});
        sqlParams.Add({"@shpAddress", NKPR_GL_SHPA1});
        sqlParams.Add({"@shpCity", NKPR_GL_SHPCTY});
        sqlParams.Add({"@shpZip", NKPR_GL_SHPZIP});
        sqlParams.Add({"@shpState", NKPR_GL_SHPST});
//sqlParams.Add({"@shpGLN", NKPR_AD_GLN"]});
        sqlParams.Add({"@payment", NKPR_GL_SIF_PL});
        sqlParams.Add({"@model", NKPR_GL_MODEL});
        sqlParams.Add({"@poziv", NKPR_GL_POZIV});
      
        sqlParams.Add({"@datpri", NKPR_GL_DATPRI});
        //sqlParams.Add({"@lineTotal", NKPR_GL_LINETOTAL});
        sqlParams.Add({"@taxTotal", NKPR_GL_TAXAMT});
        sqlParams.Add({"@total", NKPR_GL_TOTAL});
        //sqlParams.Add({"@payable", NKPR_GL_PAYABLE});
        
        sqlParams.Add({"@glDesc", NKPR_GL_DESC});
        
        // sqlParams.Add({"@note", NKPR_GL_BROPIS1});
        sqlParams.Add({"@note", 0});

        sqlParams.Add({"@rez3", NKPR_GL_REZ3});
        sqlParams.Add({"@created", NKPR_GL_INVDTE}); //????
        sqlParams.Add({"@country", NKPR_GL_DRZAVA});        
        sqlParams.Add({"@posred", NKPR_GL_POSRED}); // invoiceId
        // Execute SQL insert
        result = SqlNonQuery(sql_insert, sqlParams);
        
        if (result > 0) {
            return newRecordId;
        } else {
            throw "SQL insert neuspješan";
        }
        
    } catch (error) {
        throw "Greška prilikom unosa zaglavlja: " + error;
    }
}

// Import line items into NKNAERLN table
// Import line items into NKNAERLN table
function ImportLineItemsToERLN(recordId, lineItems) {
  //msg("Importing line items for Record ID: " + recordId);      
    try {

        // msg("lineItems: " + lineItems);

        for (i = 0; i < Size(lineItems); i++) {
            lineData = lineItems[i];
            
            // msg(lineData);

            if(!Contains(lineData, "NKPR_LN_PCODE"))
            {
                lineData["NKPR_LN_PCODE"] = "";
            }
            if(!Contains(lineData, "NKPR_LN_TXBLE"))
            {
                lineData["NKPR_LN_TXBLE"] = 0;
            }
            if(!Contains(lineData, "NKPR_LN_POPL"))
            {
                lineData["NKPR_LN_POPL"] = 0;
            }
            if(!Contains(lineData, "NKPR_LN_PDISC"))
            {
                lineData["NKPR_LN_PDISC"] = 0;
            }
            if(!Contains(lineData, "NKPR_LN_BROPI"))
            {
                lineData["NKPR_LN_BROPI"] = 0;
            }

            // msg(lineData);
    
            sql_insert = "INSERT INTO " + databaseName + ".dbo.NKNAERLN (";
            sql_insert += "NKPR_LN_INVNM, NKPR_LN_BR_LN, NKPR_LN_PQTY, NKPR_LN_AMT, ";
            sql_insert += "NKPR_LN_PCODE, NKPR_LN_PDESC, NKPR_LN_JEDMJ, ";
            sql_insert += "NKPR_LN_PPRCE, NKPR_LN_PRNPR, NKPR_LN_TXBLE, ";
            sql_insert += "NKPR_LN_POPL, NKPR_LN_PDISC, NKPR_LN_BROPI, NKPR_LN_SASTAV";
            sql_insert += ") VALUES (";
            sql_insert += "@recordId, @lineNum, @qty, @amount, ";
            sql_insert += "@productCode, @description, @unit, ";
            sql_insert += "@price, @taxPercent, @taxable, ";
            sql_insert += "@discount, @discountPercent, @note, @attachmentId";
            sql_insert += ");";
            
            sqlParams = {};
            sqlParams.Add({"@recordId", NKPR_GL_BRPON});
            
            sqlParams.Add({"@lineNum", i + 1});
            sqlParams.Add({"@qty", lineData["NKPR_LN_PQTY"]});
            sqlParams.Add({"@amount", lineData["NKPR_LN_AMT"]});
            sqlParams.Add({"@productCode", lineData["NKPR_LN_PCODE"]});
            sqlParams.Add({"@description", lineData["NKPR_LN_PDESC"]});
            sqlParams.Add({"@unit", lineData["NKPR_LN_JEDMJ"]});
            sqlParams.Add({"@price", lineData["NKPR_LN_PPRCE"]});
            sqlParams.Add({"@taxPercent", lineData["NKPR_LN_PRNPR"]});
            sqlParams.Add({"@taxable", lineData["NKPR_LN_TXBLE"]});
            sqlParams.Add({"@discount", lineData["NKPR_LN_POPL"]});
            sqlParams.Add({"@discountPercent", lineData["NKPR_LN_PDISC"]});
            sqlParams.Add({"@note", lineData["NKPR_LN_BROPI"]});
            
            // Add line item attachment ID if present
            lineAttachmentId = 0;
            if (Contains(lineData, "NKPR_LN_SASTAV")) {
                lineAttachmentId = lineData["NKPR_LN_SASTAV"];
            }
            sqlParams.Add({"@attachmentId", lineAttachmentId});
         //msg("1111");        
            result = SqlNonQuery(sql_insert, sqlParams);
            if (result == 0) {
                throw "Greška prilikom unosa stavke " + (i + 1);
            }
        }
        
        return true;
        
    } catch (error) {
        throw "Greška prilikom unosa stavki: " + error;
    }
}

// Log to NKSYELOG table
function LogToNKSYELOG(recordId, xmlFilePath, status) {
    try {
        sql_log = "INSERT INTO " + databaseName + ".dbo.NKSYELOG (";
        sql_log += "SY_ELOG_DATE, SY_ELOG_PERSON, SY_ELOG_PROGRAM, SY_ELOG_MESSAGE, ";
        sql_log += "SY_ELOG_RECORDID, SY_ELOG_STATUS";
        sql_log += ") VALUES (";
        sql_log += "@logDate, @logUser, @logProgram, @logMessage, @recordId, @status";
        sql_log += ");";
        
        sqlParams = {};
        sqlParams.Add({"@logDate", Now("yyyy-MM-dd")});
        sqlParams.Add({"@logUser", userCode});
        sqlParams.Add({"@logProgram", "WxEracunGet"});
        sqlParams.Add({"@logMessage", "XML Invoice Import: " + xmlFilePath});
        sqlParams.Add({"@recordId", recordId});
        sqlParams.Add({"@status", status});
        
        SqlNonQuery(sql_log, sqlParams);
        
    } catch (error) {
        // Don't throw error for logging issues
        MessageBox("Warning: Could not log to NKSYELOG: " + error);
    }
}

// Helper function to get next record ID
function GetNextRecordId(tableName) {
    sql_max = "SELECT isnull(MAX(NKPR_GL_BRPON),0) AS lastNum FROM " + databaseName + ".dbo." + tableName;
    result = sqlQuery(sql_max);
    if (Size(result) >= 2 && result[1][0] != 0) {
        return result[1][0] + 1;
    } else {
        // First record
        return 1; // Starting ID
    }
}
 
// Helper function to convert UN unit codes back to internal codes
function GetUnitCodeFromUN(unCode) {
    if (unCode == "H87") { return "KOM"; }
    if (unCode == "KGM") { return "KG"; }
    if (unCode == "LTR") { return "LIT"; }
    if (unCode == "MTK") { return "MX2"; }
    if (unCode == "MTQ") { return "MX3"; }
    if (unCode == "TNE") { return "TON"; }
    if (unCode == "GRM") { return "GR"; }
    if (unCode == "HUR") { return "SAT"; }
    if (unCode == "DAY") { return "DAN"; }
    if (unCode == "MTR") { return "MET"; }
    if (unCode == "XCT") { return "KAR"; }
    if (unCode == "XPB") { return "PAL"; }
    if (unCode == "C62") { return "JED"; }
    return "KOM"; // Default
}

// // Helper function to parse invoice number from UBL format
// function ParseInvoiceNumber(ublInvNum) {
//     // Convert from format "00002-90-1" to "90100002"
//     if (Contains(ublInvNum, "-")) {
//         parts = Split(ublInvNum, "-");
//         if (Size(parts) == 3) {
//             return int(parts[1] + parts[2] + parts[0]);
//         }
//     }
//     return int(ublInvNum);
// }

// Validate if invoice ESD date belongs to current fiscal year
function ValidateFiscalYear() {
    return true; // Temporarily disable fiscal year check
    try {
        //if (esdDate == "" || esdDate == null) {
        //    return false; // No ESD date provided
        //}
        
        // Parse fiscal year from KPSY_FISCAL_YR (format: YYYY-MM-DD or similar)
        fiscalYear = year(KPSY_FISCAL_YR);
        
        // Parse year from ESD date (format: YYYY-MM-DD)
        esdYear =  year(gl_esd);
        // Compare years
        return (esdYear == fiscalYear);
        
    } catch (error) {
        MessageBox("Greška prilikom validacije fiskalne godine: " + error);
        return false;
    }
}


/* 
Usage Examples:

Database Tables Used:
- NKNAERGL: Header table for imported e-invoices
- NKNAERLN: Line items table for imported e-invoices  
- NKSYELOG: System log for import tracking

Fiscal Year Validation:
- Only invoices with ESD date matching KPSY_FISCAL_YR are imported
- Mismatched invoices are moved to archive without import
*/


function LogNKSYELOG(elogStatusCode, _invoiceId, description = ""){
    sqlQueryString = "INSERT INTO " + databaseName + ".dbo.NKSYELOG 
    (sy_elog_num, sy_elog_date, sy_elog_status, sy_elog_person, sy_elog_estring, sy_elog_type, sy_elog_time, sy_elog_desc, sy_elog_rez3, sy_elog_rez)
    VALUES (@p1, @p2, @p3, @p4, @p5, @p6, @p7, @p8, @p9, @p10);";

    sqlParams = {};
    sqlParams.Add({"@p1", NKPR_GL_NUM});
    sqlParams.Add({"@p2", NKPR_GL_INVDTE});
    sqlParams.Add({"@p3", elogStatusCode.Upper()});
    sqlParams.Add({"@p4", userCode});
    sqlParams.Add({"@p5", "" });
    sqlParams.Add({"@p6", "IR"});
    sqlParams.Add({"@p7", Now("HH:mm:ss")});
    sqlParams.Add({"@p8", description});
    sqlParams.Add({"@p9", Now("yyyy-MM-dd")});
    sqlParams.Add({"@p10", _invoiceId});
    sqlQuery(sqlQueryString, sqlParams);
    return;
}

// -----------------------------------------------------------
// Extract attachments from UBL XML and save to disk
// Reverse process from wxeracun.cscs
// -----------------------------------------------------------
function ExtractAndSaveAttachments(invoiceDict, docType) {
    try {
        msg("=== ATTACHMENT EXTRACTION STARTING ===");
        
        // Get the root document data
        docData = invoiceDict;
        if (docType == "S" && Contains(invoiceDict, "Invoice")) {
            docData = invoiceDict["Invoice"];
        } elif (docType == "R" && Contains(invoiceDict, "CreditNote")) {
            docData = invoiceDict["CreditNote"];
        } elif (docType == "T" && Contains(invoiceDict, "DebitNote")) {
            docData = invoiceDict["DebitNote"];
        }
        
        // Initialize attachment counters
        NKPR_GL_PICTHDR = 0;  // Header attachment
        NKPR_GL_PICTFTR = 0;  // Footer attachment
        attachmentCounter = 0;
        
        // Process AdditionalDocumentReference elements (contains attachments)
        if (Contains(docData, "AdditionalDocumentReference")) {
            additionalDocs = docData["AdditionalDocumentReference"];
            
            // Handle both single attachment and multiple attachments
            if (additionalDocs.type() == "ARRAY") {
                for (i = 0; i < Size(additionalDocs); i++) {
                    ProcessSingleAttachment(additionalDocs[i], i);
                }
            } else {
                ProcessSingleAttachment(additionalDocs, 0);
            }
        }
        
        // Extract and save main PDF attachment if present
        if (Contains(docData, "Attachment")) {
            mainAttachment = docData["Attachment"];
            if (Contains(mainAttachment, "EmbeddedDocumentBinaryObject")) {
                ProcessMainPdfAttachment(mainAttachment);
            }
        }
        
        msg("=== ATTACHMENT EXTRACTION COMPLETE ===");
        msg("Header Attachment ID (NKPR_GL_PICTHDR): " + NKPR_GL_PICTHDR);
        msg("Footer Attachment ID (NKPR_GL_PICTFTR): " + NKPR_GL_PICTFTR);
        
        return true;
        
    } catch (error) {
        MessageBox("Greška pri extraction attachments: " + error);
        return false;
    }
}

// -----------------------------------------------------------
// Process single attachment from AdditionalDocumentReference
// -----------------------------------------------------------
function ProcessSingleAttachment(attachmentRef, attachmentIndex) {
    try {
        // Get attachment ID
        attachmentID = "";
        if (Contains(attachmentRef, "ID")) {
            attachmentID = attachmentRef["ID"];
        }
        
        // Get attachment description
        attachmentDesc = "";
        if (Contains(attachmentRef, "DocumentDescription")) {
            attachmentDesc = attachmentRef["DocumentDescription"];
        }
        
        // Extract embedded binary object
        if (Contains(attachmentRef, "Attachment")) {
            attachment = attachmentRef["Attachment"];
            if (Contains(attachment, "EmbeddedDocumentBinaryObject")) {
                embeddedObj = attachment["EmbeddedDocumentBinaryObject"];
                
                // Get MIME type and filename
                mimeCode = "";
                filename = "";
                base64Content = "";
                
                if (Contains(embeddedObj, "@attributes")) {
                    attrs = embeddedObj["@attributes"];
                    if (Contains(attrs, "mimeCode")) {
                        mimeCode = attrs["mimeCode"];
                    }
                    if (Contains(attrs, "filename")) {
                        filename = attrs["filename"];
                    }
                }
                
                // Get base64 content
                if (Contains(embeddedObj, "@text")) {
                    base64Content = embeddedObj["@text"];
                } else {
                    base64Content = embeddedObj;
                }
                
                if (base64Content != "" && filename != "") {
                    // Save attachment to disk and get reference number
                    attachmentNum = SaveAttachmentToDisk(base64Content, filename, attachmentDesc, attachmentID);
                    
                    if (attachmentNum > 0) {
                        // Determine attachment type (Header, Footer, or Line item)
                        if (attachmentIndex == 0 && NKPR_GL_PICTHDR == 0) {
                            NKPR_GL_PICTHDR = attachmentNum;
                            msg("Saved Header attachment: " + filename + " with ID: " + attachmentNum);
                        } elif (attachmentIndex == 1 && NKPR_GL_PICTFTR == 0) {
                            NKPR_GL_PICTFTR = attachmentNum;
                            msg("Saved Footer attachment: " + filename + " with ID: " + attachmentNum);
                        } else {
                            // Line item attachment - would need to store in NKNAERLN reference
                            // Store in temporary array for later processing with line items
                            msg("Saved Line attachment: " + filename + " with ID: " + attachmentNum);
                        }
                    }
                }
            }
        }
        
    } catch (error) {
        msg("Greška pri obradi attachment: " + error);
    }
}

// -----------------------------------------------------------
// Process main PDF attachment (AdditionalDocumentReference with ID=X7)
// -----------------------------------------------------------
function ProcessMainPdfAttachment(attachmentRef) {
    try {
        if (Contains(attachmentRef, "EmbeddedDocumentBinaryObject")) {
            embeddedObj = attachmentRef["EmbeddedDocumentBinaryObject"];
            
            // Get MIME type and filename
            mimeCode = "";
            filename = "";
            base64Content = "";
            
            if (Contains(embeddedObj, "@attributes")) {
                attrs = embeddedObj["@attributes"];
                if (Contains(attrs, "mimeCode")) {
                    mimeCode = attrs["mimeCode"];
                }
                if (Contains(attrs, "filename")) {
                    filename = attrs["filename"];
                }
            }
            
            // Get base64 content
            if (Contains(embeddedObj, "@text")) {
                base64Content = embeddedObj["@text"];
            } else {
                base64Content = embeddedObj;
            }
            
            if (base64Content != "" && filename != "") {
                // Save main PDF attachment
                attachmentNum = SaveAttachmentToDisk(base64Content, filename, "Main PDF Attachment", "X7");
                if (attachmentNum > 0) {
                    msg("Saved Main PDF attachment: " + filename + " with ID: " + attachmentNum);
                }
            }
        }
        
    } catch (error) {
        msg("Greška pri obradi main PDF attachment: " + error);
    }
}

// -----------------------------------------------------------
// Save attachment to disk and register in NKSYPICT table
// Returns the NKSYPICT reference number (SY_SL_NUM)
// -----------------------------------------------------------
function SaveAttachmentToDisk(base64Content, filename, description, attachmentID) {
    try {
        // Validate inputs
        if (base64Content == "" || filename == "") {
            msg("Preskakanje praznog attachment ili filename");
            return 0;
        }
        
        // Create attachment directory if needed
        attachmentDir = FILESPATH + "Attachments\\";
        if (!Exists(attachmentDir)) {
            CreateDirectory(attachmentDir);
        }
        
        // Generate unique filename with timestamp
        fileExtension = ParseFile(filename, "pfExt");
        fileNameOnly = ParseFile(filename, "pfName");
        timestamp = Now("yyyyMMdd_HHmmss");
        uniqueFilename = fileNameOnly + "_" + NKPR_GL_NUM + "_" + timestamp + fileExtension;
        fullFilePath = attachmentDir + uniqueFilename;
        
        msg("Saving attachment to: " + fullFilePath);
        
        // Convert Base64 to file
        if (!Base642File(base64Content, fullFilePath)) {
            msg("Greška pri spremanju attachment datoteke: " + fullFilePath);
            return 0;
        }
        
        msg("Attachment saved successfully: " + fullFilePath);
        
        // Get next available NKSYPICT number
        sql_max_pic = "SELECT ISNULL(MAX(SY_SL_NUM), 0) AS maxNum FROM " + databaseName + ".dbo.NKSYPICT";
        maxRes = sqlQuery(sql_max_pic);
        
        nextPicNum = 1;
        if (Size(maxRes) >= 2) {
            nextPicNum = maxRes[1][0] + 1;
        }
        
        // Insert into NKSYPICT table
        sql_insert_pic = "INSERT INTO " + databaseName + ".dbo.NKSYPICT 
            (SY_SL_NUM, SY_SL_PATH, SY_SL_OPIS, SY_SL_DATCR, SY_SL_TIMECR, SY_SL_REZ)
            VALUES (@p1, @p2, @p3, @p4, @p5, @p6);";
        
        sqlParams = {};
        sqlParams.Add({"@p1", nextPicNum});
        sqlParams.Add({"@p2", fullFilePath});
        sqlParams.Add({"@p3", description + " | XmlID: " + attachmentID});
        sqlParams.Add({"@p4", Now("yyyy-MM-dd")});
        sqlParams.Add({"@p5", Now("HH:mm:ss")});
        sqlParams.Add({"@p6", attachmentID});
        
        sqlQuery(sql_insert_pic, sqlParams);
        msg("Registered attachment in NKSYPICT with ID: " + nextPicNum);
        
        return nextPicNum;
        
    } catch (error) {
        MessageBox("Greška pri spasavanju attachment: " + error);
        return 0;
    }
}

// -----------------------------------------------------------
// Extract and save line item attachments
// Stores attachment ID in NKNAERLN.NKPR_LN_SASTAV field
// -----------------------------------------------------------
function ExtractLineItemAttachments(lineDict, lineNumber) {
    try {
        lineAttachmentID = 0;
        
        // Check if line has AttachmentReference or similar structure
        if (Contains(lineDict, "AdditionalDocumentReference")) {
            lineRef = lineDict["AdditionalDocumentReference"];
            
            // Handle both single and multiple references
            refsToProcess = {};
            if (lineRef.type() == "ARRAY") {
                refsToProcess = lineRef;
            } else {
                refsToProcess = {lineRef};
            }
            
            for (i = 0; i < Size(refsToProcess); i++) {
                ref = refsToProcess[i];
                
                // Get attachment ID
                attachmentID = "";
                if (Contains(ref, "ID")) {
                    attachmentID = ref["ID"];
                }
                
                // Get description
                attachmentDesc = "Line " + lineNumber + " attachment";
                if (Contains(ref, "DocumentDescription")) {
                    attachmentDesc = "Line " + lineNumber + ": " + ref["DocumentDescription"];
                }
                
                // Extract embedded binary object
                if (Contains(ref, "Attachment")) {
                    attachment = ref["Attachment"];
                    if (Contains(attachment, "EmbeddedDocumentBinaryObject")) {
                        embeddedObj = attachment["EmbeddedDocumentBinaryObject"];
                        
                        // Get MIME type and filename
                        mimeCode = "";
                        filename = "";
                        base64Content = "";
                        
                        if (Contains(embeddedObj, "@attributes")) {
                            attrs = embeddedObj["@attributes"];
                            if (Contains(attrs, "mimeCode")) {
                                mimeCode = attrs["mimeCode"];
                            }
                            if (Contains(attrs, "filename")) {
                                filename = attrs["filename"];
                            }
                        }
                        
                        // Get base64 content
                        if (Contains(embeddedObj, "@text")) {
                            base64Content = embeddedObj["@text"];
                        } else {
                            base64Content = embeddedObj;
                        }
                        
                        if (base64Content != "" && filename != "") {
                            // Save attachment to disk
                            lineAttachmentID = SaveAttachmentToDisk(base64Content, filename, attachmentDesc, attachmentID);
                            if (lineAttachmentID > 0) {
                                msg("Saved Line " + lineNumber + " attachment: " + filename + " with ID: " + lineAttachmentID);
                                // Return first attachment ID found for this line
                                return lineAttachmentID;
                            }
                        }
                    }
                }
            }
        }
        
        return lineAttachmentID;
        
    } catch (error) {
        msg("Greška pri extraction line item attachments: " + error);
        return 0;
    }
}